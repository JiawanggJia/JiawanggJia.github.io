<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiawanggjia.github.io</id>
    <title>Keaper&apos;s Blog</title>
    <updated>2020-09-09T17:46:02.420Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiawanggjia.github.io"/>
    <link rel="self" href="https://jiawanggjia.github.io/atom.xml"/>
    <subtitle>帝都码农一枚</subtitle>
    <logo>https://jiawanggjia.github.io/images/avatar.png</logo>
    <icon>https://jiawanggjia.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Keaper&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Java String 面面观]]></title>
        <id>https://jiawanggjia.github.io/post/java-string-mian-mian-guan/</id>
        <link href="https://jiawanggjia.github.io/post/java-string-mian-mian-guan/">
        </link>
        <updated>2020-09-08T13:03:24.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要介绍<code>Java</code>中与字符串相关的一些内容，主要包括<code>String</code>类的实现及其不变性、<code>String</code>相关类（<code>StringBuilder</code>、<code>StringBuffer</code>）的实现 以及 字符串缓存机制的用法与实现。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要介绍<code>Java</code>中与字符串相关的一些内容，主要包括<code>String</code>类的实现及其不变性、<code>String</code>相关类（<code>StringBuilder</code>、<code>StringBuffer</code>）的实现 以及 字符串缓存机制的用法与实现。</p>
<!-- more -->
<h1 id="string类的设计与实现">String类的设计与实现</h1>
<p><code>String</code>类的核心逻辑是通过对<code>char</code>型数组进行封装来实现字符串对象，但实现细节伴随着<code>Java</code>版本的演进也发生过几次变化。</p>
<h2 id="java-6">Java 6</h2>
<pre><code class="language-java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence
{
    /** The value is used for character storage. */
    private final char value[];
    /** The offset is the first index of the storage that is used. */
    private final int offset;
    /** The count is the number of characters in the String. */
    private final int count;
    /** Cache the hash code for the string */
    private int hash; // Default to 0
}
</code></pre>
<p>在<code>Java 6</code>中，<code>String</code>类有四个成员变量：<code>char</code>型数组<code>value</code>、偏移量 <code>offset</code>、字符数量 <code>count</code>、哈希值 <code>hash</code>。<code>value</code>数组用来存储字符序列， <code>offset</code> 和 <code>count</code> 两个属性用来定位字符串在<code>value</code>数组中的位置，<code>hash</code>属性用来缓存字符串的<code>hashCode</code>。</p>
<p>使用<code>offset</code>和<code>count</code>来定位<code>value</code>数组的目的是，可以高效、快速地共享<code>value</code>数组，例如<code>substring()</code>方法返回的子字符串是通过记录<code>offset</code>和<code>count</code>来实现与原字符串共享<code>value</code>数组的，而不是重新拷贝一份。<code>substring()</code>方法实现如下：</p>
<pre><code class="language-java">String(int offset, int count, char value[]) {
	this.value = value;    // 直接复用原数组
	this.offset = offset;
	this.count = count;
}
public String substring(int beginIndex, int endIndex) {
    // ...... 省略一些边界检查的代码 ......
    return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this :
        new String(offset + beginIndex, endIndex - beginIndex, value);
}
</code></pre>
<p>但是这种方式却很有可能会导致内存泄漏。例如在如下代码中：</p>
<pre><code class="language-java">String bigStr = new String(new char[100000]);
String subStr = bigStr.substring(0,2);
bigStr = null;
</code></pre>
<p>在<code>bigStr</code>被设置为<code>null</code>之后，其中的<code>value</code>数组却仍然被<code>subStr</code>所引用，导致垃圾回收器无法将其回收，结果虽然我们实际上仅仅需要<code>2</code>个字符的空间，但是实际却占用了<code>100000</code>个字符的空间。</p>
<p>在<code>Java 6</code>中，如果想要避免这种内存泄漏情况的发生，可以使用下面的方式：</p>
<pre><code class="language-java">String subStr = bigStr.substring(0,2) + &quot;&quot;;
// 或者
String subStr = new String(bigStr.substring(0,2));
</code></pre>
<p>在语句执行完之后，<code>substring</code>方法返回的匿名<code>String</code>对象由于没有被别的对象引用，所以能够被垃圾回收器回收，不会继续引用<code>bigStr</code>中的<code>value</code>数组，从而避免了内存泄漏。</p>
<h2 id="java-7-java-8">Java 7 &amp; Java 8</h2>
<pre><code class="language-java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
    /** Cache the hash code for the string */
    private int hash; // Default to 0
}
</code></pre>
<p>在<code>Java 7</code>-<code>Java 8</code>中，<code>Java</code> 对 <code>String</code> 类做了一些改变。<code>String</code> 类中不再有 <code>offset</code> 和 <code>count</code> 两个成员变量了。<code>substring()</code>方法也不再共享 <code>value</code>数组，而是从指定位置重新拷贝一份<code>value</code>数组，从而解决了使用该方法可能导致的内存泄漏问题。<code>substring()</code>方法实现如下：</p>
<pre><code class="language-java">public String(char value[], int offset, int count) {
    // ...... 省略一些边界检查的代码 ......

    // 从原数组拷贝
    this.value = Arrays.copyOfRange(value, offset, offset+count);   
}
public String substring(int beginIndex, int endIndex) {
    // ...... 省略一些边界检查的代码 ......
    return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this
            : new String(value, beginIndex, subLen);
}
</code></pre>
<h2 id="java-9">Java 9</h2>
<pre><code class="language-java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;
    /**  The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
    /** Cache the hash code for the string */
    private int hash; // Default to 0
}
</code></pre>
<p>为了节省内存空间，<code>Java 9</code>中对<code>String</code>的实现方式做了优化，<code>value</code>成员变量从<code>char[]</code>类型改为了<code>byte[]</code>类型，同时新增了一个<code>coder</code>成员变量。我们知道<code>Java</code>中<code>char</code>类型占用的是两个字节，对于只占用一个字节的字符（例如，<code>a-z</code>，<code>A-Z</code>）就显得有点浪费，所以<code>Java 9</code>中将<code>char[]</code>改为<code>byte[]</code>来存储字符序列，而新属性 <code>coder</code> 的作用就是用来表示<code>value</code>数组中存储的是双字节编码的字符还是单字节编码的字符。<code>coder</code> 属性可以有 <code>0</code> 和 <code>1</code> 两个值，<code>0</code> 代表 <code>Latin-1</code>（单字节编码），<code>1</code> 代表 <code>UTF-16</code>（双字节编码）。在创建字符串的时候如果判断所有字符都可以用单字节来编码，则使用<code>Latin-1</code>来编码以压缩空间，否则使用<code>UTF-16</code>编码。主要的构造函数实现如下：</p>
<pre><code class="language-java">String(char[] value, int off, int len, Void sig) {
    if (len == 0) {
        this.value = &quot;&quot;.value;
        this.coder = &quot;&quot;.coder;
        return;
    }
    if (COMPACT_STRINGS) {
        byte[] val = StringUTF16.compress(value, off, len);  // 尝试压缩字符串，使用单字节编码存储
        if (val != null) {   // 压缩成功，可以使用单字节编码存储
            this.value = val;
            this.coder = LATIN1;
            return;
        }
    }
    // 否则，使用双字节编码存储
    this.coder = UTF16;
    this.value = StringUTF16.toBytes(value, off, len);
}
</code></pre>
<h1 id="string类的不变性">String类的不变性</h1>
<p>我们注意到<code>String</code>类是用<code>final</code>修饰的；所有的属性都是声明为<code>private</code>的；并且除了<code>hash</code>属性之外的其他属性也都是用<code>final</code>修饰。这保证了：</p>
<ol>
<li><code>String</code>类由<code>final</code>修饰，所以无法通过继承<code>String</code>类改变其语义；</li>
<li>所有的属性都是声明为<code>private</code>的， 所以无法在<code>String</code>外部<strong>直接</strong>访问或修改其属性；</li>
<li>除了<code>hash</code>属性之外的其他属性都是用<code>final</code>修饰，表示这些属性在初始化赋值后不可以再修改。</li>
</ol>
<p>上述的定义共同实现了<code>String</code>类一个重要的特性 —— <strong>不变性</strong>，即 <code>String</code> 对象一旦创建成功，就不能再对它进行任何修改。<code>String</code>提供的方法<code>substring()</code>、<code>concat()</code>、<code>replace()</code>等方法返回值都是新创建的<code>String</code>对象，而不是原来的<code>String</code>对象。</p>
<blockquote>
<p><code>hash</code>属性不是<code>final</code>的原因是：<code>String</code>的<code>hashCode</code>并不需要在创建字符串时立即计算并赋值，而是在<code>hashCode()</code>方法被调用时才需要进行计算。</p>
</blockquote>
<p><strong>为什么String类要设计为不可变的？</strong></p>
<ol>
<li>保证 <code>String</code> 对象的安全性。<code>String</code>被广泛用作<code>JDK</code>中作为参数、返回值，例如网络连接，打开文件，类加载，等等。如果 <code>String</code> 对象是可变的，那么 <code>String</code> 对象将可能被恶意修改，引发安全问题。</li>
<li>线程安全。<code>String</code>类的不可变性天然地保证了其线程安全的特性。</li>
<li>保证了<code>String</code>对象的<code>hashCode</code>的不变性。<code>String</code>类的不可变性，保证了其<code>hashCode</code>值能够在第一次计算后进行缓存，之后无需重复计算。这使得<code>String</code>对象很适合用作<code>HashMap</code>等容器的<code>Key</code>，并且相比其他对象效率更高。</li>
<li>实现<code>字符串常量池</code>。<code>Java</code>为字符串对象设计了<code>字符串常量池</code>来共享字符串，节省内存空间。如果字符串是可变的，那么字符串对象便无法共享。因为如果改变了其中一个对象的值，那么其他对象的值也会相应发生变化。</li>
</ol>
<h1 id="与string类相关的类">与String类相关的类</h1>
<p>除了<code>String</code>类之外，还有两个与<code>String</code>类相关的的类：<code>StringBuffer</code>和<code>StringBuilder</code>，这两个类可以看作是<code>String</code>类的可变版本，提供了对字符串修改的各种方法。两者的区别在于<code>StringBuffer</code>是线程安全的而<code>StringBuilder</code>不是线程安全的。</p>
<h2 id="stringbuffer-stringbuilder的实现">StringBuffer / StringBuilder的实现</h2>
<p><code>StringBuffer</code>和<code>StringBuilder</code>都是继承自<code>AbstractStringBuilder</code>，<code>AbstractStringBuilder</code>利用可变的<code>char</code>数组（<code>Java 9</code>之后改为为<code>byte</code>数组）来实现对字符串的各种修改操作。<code>StringBuffer</code>和<code>StringBuilder</code>都是调用<code>AbstractStringBuilder</code>中的方法来操作字符串， 两者区别在于<code>StringBuffer</code>类中对字符串修改的方法都加了<code>synchronized</code>修饰，而<code>StringBuilder</code>没有，所以<code>StringBuffer</code>是线程安全的，而<code>StringBuilder</code>并非线程安全的。</p>
<p>我们以<code>Java 8</code>为例，看一下<code>AbstractStringBuilder</code>类的实现：</p>
<pre><code class="language-java">abstract class AbstractStringBuilder implements Appendable, CharSequence {
    /** The value is used for character storage. */
    char[] value;
    /** The count is the number of characters used. */
    int count;
}
</code></pre>
<p><code>value</code>数组用来存储字符序列，<code>count</code>则用来存储<code>value</code>数组中已经使用的字符数量，字符串真实的内容是<code>value</code>数组中<code>[0,count)</code>之间的字符序列，而<code>[count,length)</code>之间是<strong>未使用</strong>的空间。需要<code>count</code>属性记录已使用空间的原因是，<code>AbstractStringBuilder</code>中的<code>value</code>数组并不是每次修改都会重新申请，而是会提前预分配一定的多余空间，以此来减少重新分配数组空间的次数。（这种做法类似于<code>ArrayList</code>的实现）。</p>
<p><code>value</code>数组扩容的策略是：当对字符串进行修改时，如果当前的<code>value</code>数组不满足空间需求时，则会重新分配更大的<code>value</code>数组，分配的数组大小为<code>min( 原数组大小×2 + 2 , 所需的数组大小 )</code>，更加细节的逻辑可以参考如下代码：</p>
<pre><code class="language-java">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

private int newCapacity(int minCapacity) {
    // overflow-conscious code
    int newCapacity = (value.length &lt;&lt; 1) + 2;    //原数组大小×2 + 2 
    if (newCapacity - minCapacity &lt; 0) {     // 如果小于所需空间大小，扩展至所需空间大小
        newCapacity = minCapacity;
    }
    return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0)
        ? hugeCapacity(minCapacity)
        : newCapacity;
}

private int hugeCapacity(int minCapacity) {
    if (Integer.MAX_VALUE - minCapacity &lt; 0) { // overflow
        throw new OutOfMemoryError();
    }
    return (minCapacity &gt; MAX_ARRAY_SIZE)
        ? minCapacity : MAX_ARRAY_SIZE;
}
</code></pre>
<p>当然<code>AbstractStringBuilder</code>也提供了<code>trimToSize</code>方法去释放多余的空间：</p>
<pre><code class="language-java">public void trimToSize() {
    if (count &lt; value.length) {
        value = Arrays.copyOf(value, count);
    }
}
</code></pre>
<h1 id="string对象的缓存机制">String对象的缓存机制</h1>
<p>因为<code>String</code>对象的使用广泛，<code>Java</code>为<code>String</code>对象设计了缓存机制，以提升时间和空间上的效率。在<code>JVM</code>的运行时数据区中存在一个<code>字符串常量池</code>（<code>String Pool</code>），在这个常量池中维护了所有已经缓存的<code>String</code>对象，当我们说一个<code>String</code>对象被缓存（<code>interned</code>）了，就是指它进入了<code>字符串常量池</code>。</p>
<p>我们通过解答下面三个问题来理解<code>String</code>对象的缓存机制：</p>
<ol>
<li>哪些<code>String</code>对象会被缓存进<code>字符串常量池</code>？</li>
<li><code>String</code>对象被缓存在哪里，如何组织起来的？</li>
<li><code>String</code>对象是什么时候进入<code>字符串常量池</code>的？</li>
</ol>
<blockquote>
<p><strong>说明</strong>： 如未特殊指明，本文中提及的<code>JVM</code>实现均指的是<code>Oracle</code>的<code>HotSpot VM</code>，并且不考虑 逃逸分析（<code>escape analysis</code>）、标量替换（<code>scalar replacement</code>）、无用代码消除（<code>dead-code elimination</code>）等优化手段，测试代码基于不添加任何额外<code>JVM</code>参数的情况下运行。</p>
</blockquote>
<h2 id="预备知识">预备知识</h2>
<p>为了更好的阅读体验，在解答上面三个问题前，希望读者对以下知识点有简单了解：</p>
<ul>
<li><code>JVM</code>运行时数据区</li>
<li><code>class文件</code>的结构</li>
<li><code>JVM</code>基于栈的字节码解释执行引擎</li>
<li>类加载的过程</li>
<li><code>Java</code>中的几种常量池</li>
</ul>
<p>为了内容的完整性，我们对下文涉及较多的其中两点做简要介绍。</p>
<h3 id="类加载的过程">类加载的过程</h3>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期依次为：加载（<code>Loading</code>）、验证（<code>Verification</code>）、准备（<code>Preparation</code>）、解析（<code>Resolution</code>）、初始化（<code>Initialization</code>）、使用（<code>Using</code>）和卸载（<code>Unloading</code>）7个阶段。其中验证、准备、解析3个部分统称为连接（<code>Linking</code>）。<br>
加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<h3 id="java中的几种常量池">Java中的几种常量池</h3>
<p><strong>1. class文件中的常量池</strong><br>
我们知道<code>java</code>后缀的源代码文件会被<code>javac</code>编译为<code>class</code>后缀的<code>class文件</code>（字节码文件）。在<code>class文件</code>中有一部分内容是 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">常量池（Constant Pool）</a> ，这个常量池中主要存储两大类常量：</p>
<ul>
<li>代码中的<code>字面量</code>或者<code>常量表达式</code>的值；</li>
<li>符号引用，包括：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符等。</li>
</ul>
<p><strong>2. 运行时常量池</strong><br>
在<code>JVM</code><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5">运行时数据区（Run-Time Data Areas）</a>中，有一部分是<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.5">运行时常量池（Run-Time Constant Pool）</a>，属于<code>方法区</code>的一部分。<code>运行时常量池</code>是<code>class文件</code>中每个类或者接口的常量池（<code>Constant Pool</code> ）的运行时表示形式，<code>class文件</code>的常量池中的内容会在类加载后进入方法区的<code>运行时常量池</code>。</p>
<p><strong>3. 字符串常量池</strong><br>
<code>字符串常量池</code>（<code>String Pool</code>）也就是我们上文提到的用来缓存<code>String</code>对象的常量池。 这个常量池是全局共享的，属于运行时数据区的一部分。</p>
<h2 id="哪些string对象会被缓存进字符串常量池">哪些String对象会被缓存进字符串常量池？</h2>
<p>在<code>Java</code>中，有两种字符串会被缓存到<code>字符串常量池</code>中，一种是在代码中定义的<code>字符串字面量</code>或者<code>字符串常量表达式</code>，另一种是程序中主动调用<code>String.intern()</code>方法将当前<code>String</code>对象缓存到<code>字符串常量池</code>中。下面分别对两种方式做简要介绍。</p>
<h3 id="1-隐式缓存-字符串字面量-或者-字符串常量表达式">1. 隐式缓存 - 字符串字面量 或者 字符串常量表达式</h3>
<p>之所以称之为隐式缓存是因为我们并不需要主动去编写缓存相关代码，编译器和<code>JVM</code>会帮我们完成这部分工作。</p>
<p><strong>字符串字面量</strong><br>
第一种会被隐式缓存的字符串是 <strong>字符串字面量</strong>。<code>字面量</code> 是类型为原始类型、<code>String</code>类型、<code>null</code>类型的值在源代码中的表示形式。例如：</p>
<pre><code class="language-java">int i = 100;   // int 类型字面量
double f = 10.2;  // double 类型字面量
boolean b = true;   // boolean 类型字面量
String s = &quot;hello&quot;; // String类型字面量
Object o = null;  // null类型字面量
</code></pre>
<p><code>字符串字面量</code>是由双引号括起来的<code>0</code>个或者多个字符构成的。 <code>Java</code>会在执行过程中为<code>字符串字面量</code>创建<code>String</code>对象并加入<code>字符串常量池</code>中。例如上面代码中的<code>&quot;hello&quot;</code>就是一个<code>字符串字面量</code>，在执行过程中会先 创建一个内容为<code>&quot;hello&quot;</code>的<code>String</code>对象，并缓存到<code>字符串常量池</code>中，再将<code>s</code>引用指向这个<code>String</code>对象。</p>
<p>关于<code>字符串字面量</code>更加详细的内容请参阅<code>Java语言规范</code>（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5">JLS - 3.10.5. String Literals</a>）。</p>
<p><strong>字符串常量表达式</strong><br>
另外一种会被隐式缓存的字符串是 <strong>字符串常量表达式</strong>。<code>常量表达式</code>指的是表示简单类型值或<code>String</code>对象的表达式，可以简单理解为<code>常量表达式</code>就是在编译期间就能确定值的表达式。<code>字符串常量表达式</code>就是表示<code>String</code>对象的常量表达式。例如：</p>
<pre><code class="language-java">int a = 1 + 2;
double d = 10 + 2.01;
boolean b = true &amp; false;
String str1 =  &quot;abc&quot; + 123;

final int num = 456;
String  str2 = &quot;abc&quot; +456;
</code></pre>
<p><code>Java</code>会在执行过程中为<code>字符串常量表达式</code>创建<code>String</code>对象并加入<code>字符串常量池</code>中。例如，上面的代码中，会分别创建<code>&quot;abc123&quot;</code>和<code>&quot;abc456&quot;</code>两个<code>String</code>对象，这两个<code>String</code>对象会被缓存到<code>字符串常量池</code>中，<code>str1</code>会指向常量池中值为<code>&quot;abc123&quot;</code>的<code>String</code>对象，<code>str2</code>会指向常量池中值为<code>&quot;abc456&quot;</code>的<code>String</code>对象。</p>
<p>关于<code>常量表达式</code>更加详细的内容请参阅<code>Java语言规范</code>（<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28">JLS - 15.28 Constant Expressions</a>）。</p>
<h3 id="2-主动缓存-stringintern方法">2. 主动缓存 - String.intern()方法</h3>
<p>除了声明为<code>字符串字面量</code>/<code>字符串常量表达式</code>之外，通过其他方式得到的<code>String</code>对象也可以主动加入<code>字符串常量池</code>中。例如：</p>
<pre><code class="language-java">String str = new String(&quot;123&quot;) + new String(&quot;456&quot;);
str.intern();
</code></pre>
<p>在上面的代码中，在执行完第一句后，常量池中存在内容为<code>&quot;123&quot;</code>和<code>&quot;456&quot;</code>的两个<code>String</code>对象，但是不存在<code>&quot;123456&quot;</code>的<code>String</code>对象，但在执行完<code>str.intern();</code>之后，内容为<code>&quot;123456&quot;</code>的<code>String</code>对象也加入到了<code>字符串常量池</code>中。</p>
<p>我们通过<code>String.intern()</code>方法的注释来看下其具体的缓存机制：</p>
<blockquote>
<p>When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.<br>
It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.</p>
</blockquote>
<p>简单翻译一下：</p>
<blockquote>
<p>当调用 <code>intern</code> 方法时，如果常量池中已经包含相同内容的字符串（字符串内容相同由 <code>equals (Object)</code> 方法确定，对于 <code>String</code> 对象来说，也就是字符序列相同），则返回常量池中的字符串对象。否则，将此 <code>String</code> 对象将添加到常量池中，并返回此 <code>String</code> 对象的引用。<br>
因此，对于任意两个字符串 <code>s</code> 和 <code>t</code>，当且仅当 <code>s.equals(t)</code>的结果为<code>true</code>时，<code>s.intern() == t.intern()</code>的结果为<code>true</code>。</p>
</blockquote>
<h2 id="string对象被缓存在哪里如何组织起来的">String对象被缓存在哪里，如何组织起来的？</h2>
<p><code>HotSpot VM</code>中，有一个用来记录缓存的<code>String</code>对象的全局表，叫做<code>StringTable</code>，结构及实现方式都类似于<code>Java</code>中的<code>HashMap</code>或者<code>HashSet</code>，是一个使用拉链法解决哈希冲突的哈希表，可以简单理解为<code>HashSet&lt;String&gt;</code>，注意它只存储对<code>String</code>对象的引用，而不存储<code>String</code>对象实例。 一般我们说一个字符串进入了<code>字符串常量池</code>其实是说在这个<code>StringTable</code>中保存了对它的引用，反之，如果说没有在其中就是说<code>StringTable</code>中没有对它的引用。</p>
<p>而真正的字符串对象其实是保存在另外的区域中的，在<code>Java 6</code>中<code>字符串常量池</code>中的<code>String</code>对象是存储在<code>永久代</code>（<code>Java 8</code>之前<code>HotSpot VM</code>对<code>方法区</code>的实现）中的，而在<code>Java 6</code>之后，<code>字符串常量池</code>中的<code>String</code>对象是存储在<code>堆</code>中的。</p>
<blockquote>
<p><code>Java 7</code>中将<code>字符串常量池</code>中的对象移动到<code>堆</code>中的原因是在 <code>Java 6</code>中，<code>字符串常量池</code>中的对象在<code>永久代</code>创建，而<code>永久代</code>代的大小一般不会设置太大，如果大量使用字符串缓存将可能对导致<code>永久代</code>发生<code>OOM</code>异常。</p>
</blockquote>
<h2 id="string对象是什么时候进入字符串常量池的">String对象是什么时候进入字符串常量池的？</h2>
<p>对于通过 在程序中调用<code>String.intern()</code>方法主动缓存进入常量池的<code>String</code>对象，很显然就是在调用<code>intern()</code>方法的时候进入常量池的。</p>
<p>我们重点来研究一下会被隐式缓存的两种值（<code>字符串字面量</code>和<code>字符串常量表达式</code>），主要是两个问题：</p>
<ol>
<li>我们并没有主动调用<code>String</code>类的构造方法，那么它们是在何时被创建？</li>
<li>它们是在何时进入<code>字符串常量池</code>的？</li>
</ol>
<p>我们以下面的代码为例来分析这两个问题：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        String str1 = &quot;123&quot; + 123;     // 字符串常量表达式
        String str2 = &quot;123456&quot;;         // 字面量
        String str3 = &quot;123&quot; + 456;   //字符串常量表达式
    }
}
</code></pre>
<h3 id="字节码分析">字节码分析</h3>
<p>我们对上述代码编译之后使用<code>javap</code>来观察一下字节码文件，为了节省篇幅，只摘取了相关的部分：常量池表部分以及<code>main</code>方法信息部分：</p>
<pre><code class="language-java">Constant pool:
  #1 = Methodref          #5.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
  #2 = String             #24            // 123123
  #3 = String             #25            // 123456
   // ...... 省略 ......
  #24 = Utf8               123123
  #25 = Utf8               123456
 
 // ...... 省略 ......

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=4, args_size=1
         0: ldc           #2                  // String 123123
         2: astore_1
         3: ldc           #3                  // String 123456
         5: astore_2
         6: ldc           #3                  // String 123456
         8: astore_3
         9: return
      LineNumberTable:
        line 7: 0
        line 8: 3
        line 9: 6
        line 10: 9
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  args   [Ljava/lang/String;
            3       7     1  str1   Ljava/lang/String;
            6       4     2  str2   Ljava/lang/String;
            9       1     3  str3   Ljava/lang/String;
</code></pre>
<p>在<code>常量池</code>中，有两种与字符串相关的常量类型，<code>CONSTANT_String</code>和<code>CONSTANT_Utf8</code>。<code>CONSTANT_String</code>类型的常量用于表示<code>String</code>类型的常量对象，其内容只是一个常量池的索引值<code>index</code>，<code>index</code>处的成员必须是<code>CONSTANT_Utf8</code>类型。而<code>CONSTANT_Utf8</code>类型的常量用于存储真正的字符串内容。<br>
例如，上面的常量池中的第<code>2</code>、<code>3</code>项是<code>CONSTANT_String</code>类型，存储的索引分别为<code>24</code>、<code>25</code>，常量池中第<code>24</code>、<code>25</code>项就是<code>CONSTANT_Utf8</code>，存储的值分别为<code>&quot;123123&quot;</code>，<code>&quot;123456&quot;</code>。</p>
<p><code>class文件</code>的方法信息中<code>Code</code>属性是<code>class文件</code>中最为重要的部分之一，其中包含了执行语句对应的虚拟机指令，异常表，本地变量信息等，其中<code>LocalVariableTable</code>是本地变量的信息，<code>Slot</code>可以理解为本地变量表中的索引位置。<code>ldc</code>指令的作用是从<code>运行时常量池</code>中提取指定索引位置的数据并压入栈中；<code>astore_&lt;n&gt;</code>指令的作用是将一个引用类型的值从栈中弹出并保存到本地变量表的指定位置，也就是<code>&lt;n&gt;</code>指定的位置。可以看出三条赋值语句所对应的字节码指令其实都是相同的：</p>
<pre><code class="language-java">ldc           #&lt;index&gt;   // 首先将常量池中指定索引位置的String对象压入栈中
astore_&lt;n&gt;   // 然后从栈中弹出刚刚存入的String对象保存到本地变量的指定位置
</code></pre>
<h3 id="运行过程分析">运行过程分析</h3>
<p>还是围绕上面的代码，我们结合 从编译到执行的过程 来分析一下<code>字符串字面量</code>和<code>字符串常量表达式</code>的<strong>创建</strong>及<strong>缓存</strong>时机。</p>
<p><strong>1. 编译</strong><br>
首先，第一步是<code>javac</code>将源代码编译为<code>class</code>文件。在源代码编译过程中，我们上文提到的两种值 <code>字符串字面量</code>（<code>&quot;123456&quot;</code>） 和 <code>字符串常量表达式</code>（<code>&quot;123&quot; + 456</code>）这两类值都会存在编译后的<code>class文件</code>的常量池中，常量类型为<code>CONSTANT_String</code>。值得注意的两点是：</p>
<ul>
<li><code>字符串常量表达式</code>会在编译期计算出真实值存在<code>class</code>文件的<code>常量池</code>中。例如上面源代码中的<code>&quot;123&quot; + 123</code>这个表达式在<code>class</code>文件的常量池中的表现形式是<code>123123</code>，<code>&quot;123&quot; + 456</code>这个表达式在<code>class</code>文件的常量池中的表现形式是<code>123456</code>；</li>
<li>值相同的<code>字符串字面量</code>或者<code>字符串常量表达式</code>在<code>class文件</code>的常量池中只会存在一个常量项（<code>CONSTANT_String</code>类型和<code>CONSTANT_Utf8</code>都只有一项）。例如上面源代码中，虽然声明了两个常量值分别为<code>&quot;123456&quot;</code>和<code>&quot;123&quot; + 456</code>，但是最后<code>class</code>文件的常量池中只有一个值为<code>123456</code>的<code>CONSTANT_Utf8</code>常量项以及一个对应的<code>CONSTANT_String</code>常量项。</li>
</ul>
<p><strong>2. 类加载</strong><br>
在<code>JVM</code>运行时，加载<code>Main</code>类时，<code>JVM</code>会根据 <code>class文件</code>的常量池 创建 <code>运行时常量池</code>， <code>class文件</code>的常量池 中的内容会在类加载时进入方法区的 <code>运行时常量池</code>。对于<code>class文件</code>的常量池中的符号引用，会在类加载的<code>解析(resolve)阶段</code>，会将其转化为真正的值。但在<code>HotSpot</code>中，符号引用的<code>解析</code>并不一定是在类加载时立即执行的，而是推迟到第一次执行相关指令（即引用了符号引用的指令，<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3">JLS - 5.4.3. Resolution</a> ）时才会去真正进行解析，这就做<code>延迟解析</code>/<code>惰性解析</code>（<code>&quot;lazy&quot; or &quot;late&quot; resolution</code>）。</p>
<ul>
<li>对于一些基本类型的常量项，例如<code>CONSTANT_Integer_info</code>，<code>CONSTANT_Float_info</code>，<code>CONSTANT_Long_info</code>，<code>CONSTANT_Double_info</code>，在类加载阶段会将<code>class</code>文件常量池中的值转化为<code>运行时常量池</code>中的值，分别对应<code>C++</code>中的<code>int</code>，<code>float</code>，<code>long</code>，<code>double</code>类型；</li>
<li>对于<code>CONSTANT_Utf8</code>类型的常量项，在类加载的解析阶段被转化为<code>Symbol</code>对象（<code>HotSpot VM</code>层面的一个<code>C++</code>对象）。同时<code>HotSpot</code>使用<code>SymbolTable</code>（结构与<code>StringTable</code>类似）来缓存<code>Symbol</code>对象，所以在类加载完成后，<code>SymbolTable</code>中应该有所有的<code>CONSTANT_Utf8</code>常量对应的<code>Symbol</code>对象；</li>
<li>而对于<code>CONSTANT_String</code>类型的常量项，因为其内容是一个符号引用（指向<code>CONSTANT_Utf8</code>类型常量的索引值），所以需要进行解析，在类加载的解析阶段会将其转化为<code>java.lang.String</code>对象对应的<code>oop</code>（可以理解为<code>Java</code>对象在<code>HotSpot VM</code>层面的表示），并使用<code>StringTable</code>来进行缓存。但是<code>CONSTANT_String</code>类型的常量，属于上文提到的<code>延迟解析</code>的范畴，也就是在类加载时并不会立即执行解析，而是等到第一次执行相关指令时（一般来说是<code>ldc</code>指令）才会真正解析。</li>
</ul>
<p><strong>3. 执行指令</strong><br>
上面提到，<code>JVM</code>会在第一次执行相关指令的时候去执行真正的解析，对于上文给出的代码，观察字节码可以发现，<code>ldc</code>指令中使用到了符号引用，所以在执行<code>ldc</code>指令时，需要进行解析操作。那么<code>ldc</code>指令到底做了什么呢？</p>
<p><code>ldc</code>指令会从<code>运行时常量池</code>中查找指定<code>index</code>对应的常量项，并将其压入栈中。如果该项还未解析，则需要先进行解析，将符号引用转化为具体的值，然后再将其压入栈中。如果这个未解析的项是<code>String</code>类型的常量，则先从<code>字符串常量池</code>中查找是否已经有了相同内容的<code>String</code>对象，如果有则直接将<code>字符串常量池</code>中的该对象压入栈中；如果没有，则会创建一个新的<code>String</code>对象加入<code>字符串常量池</code>中，并将创建的新对象压入栈中。可见，如果代码中声明多个相同内容的<code>字符串字面量</code>或者<code>字符串常量表达式</code>，那么只会在第一次执行<code>ldc</code>指令时创建一个<code>String</code>对象，后续相同的<code>ldc</code>指令执行时相应位置的常量已经解析过了，直接压入栈中即可。</p>
<p>总结一下：</p>
<ol>
<li><strong>在编译阶段，源码中<code>字符串字面量</code>或者<code>字符串常量表达式</code>转化为了<code>class文件</code>的常量池中的<code>CONSTANT_String</code>常量项。</strong></li>
<li><strong>在类加载阶段，<code>class文件</code>的<code>常量池</code>中的<code>CONSTANT_String</code>常量项被存入了<code>运行时常量池</code>中，但保存的内容仍然是一个符号引用，未进行解析。</strong></li>
<li><strong>在指令执行阶段，当第一次执行<code>ldc</code>指令时，<code>运行时常量池</code>中的<code>CONSTANT_String</code>项还未解析，会真正执行解析，解析过程中会创建<code>String</code>对象并加入<code>字符串</code>常量池。</strong></li>
</ol>
<h2 id="缓存关键源码分析">缓存关键源码分析</h2>
<p>可以看到，其实<code>ldc</code>指令在解析<code>String</code>类型常量的时候与<code>String.intern()</code>方法的逻辑很相似：</p>
<ol>
<li><code>ldc</code>指令中解析<code>String</code>常量：先从<code>字符串常量池</code>中查找是否有相同内容的<code>String</code>对象，如果有则将其压入栈中，如果没有，则创建新对象加入<code>字符串常量池</code>并压入栈中。</li>
<li><code>String.intern()</code>方法：先从<code>字符串常量池</code>中查找是否有相同内容的<code>String</code>对象，如果有则返回该对象引用，如果没有，则将自身加入<code>字符串常量池</code>并返回。</li>
</ol>
<p>实际在<code>HotSpot</code>内部实现上，<code>ldc</code>指令 与 <code>String.intern()</code>对应的<code>native</code>方法 调用了相同的内部方法。我们以<code>OpenJDK 8</code>的源代码为例，简单分析一下其过程，代码如下（源码位置：<code>src/share/vm/classfile/SymbolTable.cpp</code>）：</p>
<pre><code class="language-java">
// String.intern()方法会调用这个方法
// 参数 &quot;oop string&quot;代表调用intern()方法的String对象
oop StringTable::intern(oop string, TRAPS)
{
  if (string == NULL) return NULL;
  ResourceMark rm(THREAD);
  int length;
  Handle h_string (THREAD, string);
  jchar* chars = java_lang_String::as_unicode_string(string, length, CHECK_NULL);    // 将String对象转化为字符序列
  oop result = intern(h_string, chars, length, CHECK_NULL);
  return result;
}

// ldc指令执行时会调用这个方法
// 参数 &quot;Symbol* symbol&quot; 是 运行时常量池 中 ldc指令的参数（索引位置）对应位置的Symbol对象
oop StringTable::intern(Symbol* symbol, TRAPS) {
  if (symbol == NULL) return NULL;
  ResourceMark rm(THREAD);
  int length;
  jchar* chars = symbol-&gt;as_unicode(length);   // 将Symbol对象转化为字符序列
  Handle string;
  oop result = intern(string, chars, length, CHECK_NULL);
  return result;
}

// 上面两个方法都会调用这个方法
oop StringTable::intern(Handle string_or_null, jchar* name, int len, TRAPS) {
  // 尝试从字符串常量池中寻找
  unsigned int hashValue = hash_string(name, len);
  int index = the_table()-&gt;hash_to_index(hashValue);
  oop found_string = the_table()-&gt;lookup(index, name, len, hashValue);

  // 如果找到了直接返回
  if (found_string != NULL) {
    ensure_string_alive(found_string);
    return found_string;
  }

   // ...... 省略部分代码 ......
   
  Handle string;
  // 尝试复用原字符串，如果无法复用，则会创建新字符串
  // JDK 6中这里的实现有一些不同，只有string_or_null已经存在于永久代中才会复用
  if (!string_or_null.is_null()) {
    string = string_or_null;
  } else {
    string = java_lang_String::create_from_unicode(name, len, CHECK_NULL);
  }

  //...... 省略部分代码 ......

  oop added_or_found;
  {
    MutexLocker ml(StringTable_lock, THREAD);
    // 添加字符串到 StringTable 中
    added_or_found = the_table()-&gt;basic_add(index, string, name, len,
                                  hashValue, CHECK_NULL);
  }
  ensure_string_alive(added_or_found);
  return added_or_found;
}
</code></pre>
<h2 id="案例分析">案例分析</h2>
<blockquote>
<p><strong>说明</strong>：因为在<code>Java 6</code>之后<code>字符串常量池</code>从<code>永久代</code>移到了<code>堆</code>中，可能在一些代码上<code>Java 6</code>与之后的版本表现不一致。所以下面的代码都使用<code>Java 6</code>和<code>Java 7</code>分别进行测试，如果未特殊说明，表示在两个版本上结果相同，如果不同，会单独指出。</p>
</blockquote>
<hr>
<pre><code class="language-java">final int a = 4;
int b = 4;
String s1 = &quot;123&quot; + a + &quot;567&quot;;
String s2 = &quot;123&quot; + b + &quot;567&quot;;
String s3 = &quot;1234567&quot;;
System.out.println(s1 == s2);
System.out.println(s1 == s3);
System.out.println(s2 == s3);
</code></pre>
<p>结果：</p>
<pre><code class="language-java">false
true
false
</code></pre>
<p>解释：</p>
<ol>
<li>第三行，因为<code>a</code>被定义为常量，所以<code>&quot;123&quot; + a + &quot;567&quot;</code>是一个<code>常量表达式</code>，在编译期会被编译为<code>&quot;1234567&quot;</code>，所以会在<code>字符串常量池</code>中创建<code>&quot;1234567&quot;</code>，<code>s1</code>指向<code>字符串常量池</code>中的<code>&quot;1234567&quot;</code>；</li>
<li>第四行，<code>b</code>被定义为变量，<code>&quot;123&quot;</code>和<code>&quot;567&quot;</code>是<code>字符串字面量</code>，所以首先在<code>字符串常量池</code>中创建<code>&quot;123&quot;</code>和<code>&quot;567&quot;</code>，然后通过<code>StringBuilder</code>隐式拼接在堆中创建<code>&quot;1234567&quot;</code>，<code>s2</code>指向堆中的<code>&quot;1234567&quot;</code>；</li>
<li>第五行，<code>&quot;1234567&quot;</code>是一个<code>字符串字面量</code>，因为此时<code>字符串常量池</code>中已经存在了<code>&quot;1234567&quot;</code>，所以<code>s3</code>指向字符串<code>字符串常量池</code>中的<code>&quot;1234567&quot;</code>。</li>
</ol>
<hr>
<pre><code class="language-java">String s1 = new String(&quot;123&quot;);
String s2 = s1.intern();
String s3 = &quot;123&quot;;
System.out.println(s1 == s2); 
System.out.println(s1 == s3); 
System.out.println(s2 == s3);
</code></pre>
<p>结果：</p>
<pre><code class="language-java">false
false
true
</code></pre>
<p>解释：</p>
<ol>
<li>第一行，<code>&quot;123&quot;</code>是一个<code>字符串字面量</code>，所以首先在<code>字符串常量池</code>中创建了一个<code>&quot;123&quot;</code>对象，然后使用<code>String</code>的构造函数在堆中创建了一个<code>&quot;123&quot;</code>对象，<code>s1</code>指向堆中的<code>&quot;123&quot;</code>；</li>
<li>第二行，因为<code>字符串常量池</code>中已经有了<code>&quot;123&quot;</code>，所以<code>s2</code>指向<code>字符串常量池</code>中的<code>&quot;123&quot;</code>；</li>
<li>第三行，同样因为<code>字符串常量池</code>中已经有了<code>&quot;123&quot;</code>，所以<code>s3</code>指向<code>字符串常量池</code>中的<code>&quot;123&quot;</code>。</li>
</ol>
<hr>
<pre><code class="language-java">String s1 = String.valueOf(&quot;123&quot;);
String s2 = s1.intern();
String s3 = &quot;123&quot;;
System.out.println(s1 == s2); 
System.out.println(s1 == s3); 
System.out.println(s2 == s3); 
</code></pre>
<p>结果：</p>
<pre><code class="language-java">true
true
true
</code></pre>
<p>解释：与上一种情况的区别在于，<code>String.valueOf()</code>方法在参数为<code>String</code>对象的时候会直接将参数作为返回值，不会在堆上创建新对象，所以<code>s1</code>也指向<code>字符串常量池</code>中的<code>&quot;123&quot;</code>，三个变量指向同一个对象。</p>
<hr>
<pre><code class="language-java">String s1 = new String(&quot;123&quot;) + new String(&quot;456&quot;); 
String s2 = s1.intern();
String s3 = &quot;123456&quot;;
System.out.println(s1 == s2); 
System.out.println(s1 == s3); 
System.out.println(s2 == s3);
</code></pre>
<p>上面的代码在<code>Java 6</code>和<code>Java 7</code>中结果是不同的。<br>
在<code>Java 6</code>中：</p>
<pre><code class="language-java">false
false
true
</code></pre>
<p>解释：</p>
<ol>
<li>第一行，<code>&quot;123&quot;</code>和<code>&quot;456&quot;</code>是<code>字符串字面量</code>，所以首先在<code>字符串常量池</code>中创建<code>&quot;123&quot;</code>和<code>&quot;456&quot;</code>，<code>+</code>操作符通过<code>StringBuilder</code>隐式拼接在堆中创建<code>&quot;123456&quot;</code>，<code>s1</code>指向堆中的<code>&quot;123456&quot;</code>；</li>
<li>第二行，将<code>&quot;123456&quot;</code>缓存到<code>字符串常量池</code>中，因为<code>Java 6</code>中<code>字符串常量池</code>中的对象是在永久代创建的，所以会在<code>字符串常量池</code>（永久代）创建一个<code>&quot;123456&quot;</code>，此时在堆中和永久代中各有一个<code>&quot;123456&quot;</code>，<code>s2</code>指向<code>字符串常量池</code>（永久代）中的<code>&quot;123456&quot;</code>；</li>
<li>第三行，<code>&quot;123456&quot;</code>是<code>字符串字面量</code>，因为此时<code>字符串常量池</code>（永久代）中已经存在<code>&quot;123456&quot;</code>，所以<code>s3</code>指向<code>字符串常量池</code>（永久代）中的<code>&quot;123456&quot;</code>。</li>
</ol>
<p>在<code>Java 7</code>中：</p>
<pre><code class="language-java">true
true
true
</code></pre>
<p>解释：与<code>Java 6</code>的区别在于，因为<code>Java 7</code>中<code>字符串常量池</code>中的对象是在<code>堆</code>上创建的，所以当执行第二行<code>String s2 = s1.intern();</code>时不会再创建新的<code>String</code>对象，而是直接将<code>s1</code>的引用添加到<code>StringTable</code>中，所以三个对象都指向常量池中的<code>&quot;123456&quot;</code>，也就是第一行中在堆中创建的对象。</p>
<blockquote>
<p><code>Java 7</code>下，<code>s1 == s2</code>结果为<code>true</code>也能够用来佐证我们上面<code>延迟解析</code>的过程。我们假设如果<code>&quot;123456&quot;</code>不是延迟解析的，而是类加载的时候解析完成并进入常量池的，<code>s1.intern()</code>的返回值应该是常量池中存在的<code>&quot;123456&quot;</code>，而不会将<code>s1</code>指向的堆中的<code>&quot;123456&quot;</code>对象加入常量池，所以结果应该是<code>s2</code>不等于<code>s1</code>而等于<code>s3</code>。</p>
</blockquote>
<hr>
<pre><code class="language-java">String s1 = new String(&quot;123&quot;) + new String(&quot;456&quot;);
String s2 = &quot;123456&quot;;
String s3 = s1.intern();
System.out.println(s1 == s2); 
System.out.println(s1 == s3); 
System.out.println(s2 == s3);
</code></pre>
<p>结果：</p>
<pre><code class="language-java">false
false
true
</code></pre>
<p>解释：</p>
<ol>
<li>第一行，<code>&quot;123&quot;</code>和<code>&quot;456&quot;</code>是<code>字符串字面量</code>，所以首先在<code>字符串常量池</code>中创建<code>&quot;123&quot;</code>和<code>&quot;456&quot;</code>，<code>+</code>操作符通过<code>StringBuilder</code>隐式拼接在堆中创建<code>&quot;123456&quot;</code>，<code>s1</code>指向堆中的<code>&quot;123456&quot;</code>；</li>
<li>第二行，<code>&quot;123456&quot;</code>是字符串字面量，此时字符串常量池中不存在<code>&quot;123456&quot;</code>，所以在<code>字符串常量池</code>中创建<code>&quot;123456&quot;</code>， <code>s2</code>指向<code>字符串常量池</code>中的<code>&quot;123456&quot;</code>；</li>
<li>第三行，因为此时字符串常量池中已经存在<code>&quot;123456&quot;</code>，所以<code>s3</code>指向<code>字符串常量池</code>中的<code>&quot;123456&quot;</code>。</li>
</ol>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://www.geeksforgeeks.org/java-substring-method-memory-leak-issue-and-fix/">Java substring() method memory leak issue and fix</a></li>
<li><a href="https://stackoverflow.com/questions/15612157/substring-method-in-string-class-causes-memory-leak">java - substring method in String class causes memory leak - Stack Overflow</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5">JLS - 3.10.5. String Literals</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28">JLS - 15.28 Constant Expressions</a></li>
<li><a href="http://java-performance.info/string-intern-in-java-6-7-8/">String.intern in Java 6, 7 and 8 – string pooling</a></li>
<li><a href="https://www.zhihu.com/question/55994121/answer/147296098">(Java 中new String(&quot;字面量&quot;) 中 &quot;字面量&quot; 是何时进入字符串常量池的? - 木女孩的回答 - 知乎</a></li>
<li><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">深入解析String#intern</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3">JLS - 5.4.3. Resolution</a></li>
<li><a href="https://www.iteye.com/blog/rednaxelafx-774673">请别再拿“String s = new String(&quot;xyz&quot;);创建了多少个String实例”来面试了吧</a></li>
<li><a href="https://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a></li>
<li><a href="https://wu-sheng.github.io/me/articles/JVMInternals">探秘JVM内部结构（翻译）</a></li>
<li><a href="https://blog.csdn.net/u010349169/category_9263262.html">Java虚拟机原理图解</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenJDK 编译调试指南 - 番外篇]]></title>
        <id>https://jiawanggjia.github.io/post/openjdk-bian-yi-diao-shi-zhi-nan-fan-wai-pian/</id>
        <link href="https://jiawanggjia.github.io/post/openjdk-bian-yi-diao-shi-zhi-nan-fan-wai-pian/">
        </link>
        <updated>2020-09-03T12:22:51.000Z</updated>
        <summary type="html"><![CDATA[<p>作为<a href="https://jiawanggjia.github.io/post/openjdk-bian-yi-zhi-nan/">OpenJDK 编译调试指南(Ubuntu 16.04 + MacOS 10.15)</a>的番外篇，本文主要用来记录在调试<code>OpenJDK</code>过程过程中遇到的一些问题以及解决办法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>作为<a href="https://jiawanggjia.github.io/post/openjdk-bian-yi-zhi-nan/">OpenJDK 编译调试指南(Ubuntu 16.04 + MacOS 10.15)</a>的番外篇，本文主要用来记录在调试<code>OpenJDK</code>过程过程中遇到的一些问题以及解决办法。</p>
<!-- more -->
<h1 id="如何编译零汇编zero-assembler的openjdk">如何编译&quot;零汇编(Zero-Assembler)&quot;的OpenJDK</h1>
<p>在使用<code>JetBrains CLion</code>调试<code>OpenJDK</code>的过程中，发现有时候<code>Call Stack</code>中有一部分是汇编代码，导致我们无法完全探究其内部实现。有没有办法能够不使用这部分汇编代码呢？</p>
<p>首先我们来看下为什么会存在部分汇编代码？</p>
<h2 id="为什么存在部分汇编代码">为什么存在部分汇编代码？</h2>
<p>从 <a href="https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html#Interpreter%7Coutline">HotSpot Runtime Overview - Interpreter</a> 了解到，<code>HotSpot</code>为了提高性能，使用了基于模板的解释器（<code>template based interpreter</code>）来解释执行<code>JAVA虚拟机指令</code>，<code>JVM</code>在启动时会根据<code>TemplateTable</code>（与每个字节码对应的汇编代码）来生成解释器，所以说这个解释器其实是部分基于汇编代码实现的。除了解释器之外，在<code>OpenJDK</code>项目中还有一些部分也是基于汇编代码的，例如<code>即时编译器JIT</code>（<code>C1</code>编译器，<code>C2</code>编译器）等，但汇编代码是依赖于硬件架构的，这种做法在提升了性能的同时却降低了可移植性。</p>
<p><code>OpenJDK</code>社区的<code>IcedTea</code>项目提供了一种比较通用的移植方法，使得<code>OpenJDK</code>可以在所有的<code>Linux</code>系统上构建， 而无需进一步进行移植工作。</p>
<h2 id="icedtea项目">IcedTea项目</h2>
<p><code>IcedTea</code>项目最初的出现是因为<code>Sun</code>公司在发布<code>JDK</code>时，类库的一些部分由于产权原因没有发布其源代码，而是仅以二进制插件的形式提供， 因为这部分源代码属于受版权保护的第三方。<code>IcedTea</code>的主要目标就是提供这些二进制插件的免费等效替代品，使得完全使用免费开源软件构建<code>JDK</code>成为可能。</p>
<p>此外，<code>IdeaTea</code>还做了很多工作以促进用户更容易地构建和部署<code>JDK</code>，其中包括将<code>OpenJDK</code>移植到更多的平台。</p>
<p>因为<code>OpenJDK</code>的代码中除了 <code>C++</code> 代码之外还包含许多汇编代码，而<code>OpenJDK</code>支持的硬件平台架构有限，远远少于<code>Linux</code>系统所支持的。于是<code>IcedTea</code>的子项目<code>Zero</code>出现了，<code>Zero</code>项目旨在通过移除<code>OpenJDK</code>项目代码中的与平台相关的汇编代码，使用纯<code>C++</code>来替代，从而可以在任何 <code>Linux</code> 系统上构建，而无需进一步进行移植工作。</p>
<blockquote>
<p>这也正是标题中&quot;零汇编&quot;的含义所在，就是指不使用汇编代码来构建<code>OpenJDK</code>。</p>
</blockquote>
<p><code>OpenJDK</code> 的虚拟机在很大程度上依赖 <code>JIT（即时编译器）</code> 编译来提高性能。而<code>Zero</code>中只包含一个纯<code>C++</code>解释器，<code>Zero</code> 在相同的硬件上要比原始（<code>vanilla</code>）的 <code>OpenJDK</code> 慢得多。于是又一个子项目<code>Shark</code>出现了， <code>Shark</code>使用 <code>LLVM</code> 来即时编译 <code>Java</code> 方法，从而在不引入系统特定的代码的情况下提高性能。</p>
<h2 id="如何实现零汇编zero-assembler">如何实现&quot;零汇编(Zero-Assembler)&quot;</h2>
<p>到这里我们已经明白了，使用<code>zero</code>来构建<code>OpenJDK</code>就可以实现&quot;零汇编(<code>Zero-Assembler</code>)&quot;，那么如何使用呢？目前<code>Zero</code>和<code>Shark</code>已经集成到了<code>OpenJDK</code>的主分支中，只要在配置<code>OpenJDK</code>的时候指定参数<code>--with-jvm-variants=zero</code>重新编译即可。</p>
<pre><code class="language-shell">sh ./configure  --with-jvm-variants=zero # 未列出全部参数
make all
</code></pre>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html#Interpreter%7Coutline">HotSpot Runtime Overview - Interpreter</a></li>
<li><a href="https://jerboaa.fedorapeople.org/presentations/OpenJDK_Zero_FOSDEM_2015-02-01.pdf">Sustaining the zero assembler port in OpenJDK: An inside perspective of CPU specific issues</a></li>
<li><a href="https://metebalci.com/blog/demystifying-the-jvm-jvm-variants-cppinterpreter-and-templateinterpreter/">Demystifying the JVM: JVM Variants, Cppinterpreter and TemplateInterpreter</a></li>
<li><a href="https://openjdk.java.net/projects/icedtea/">OpenJDK: IcedTea Project</a></li>
<li><a href="https://en.wikipedia.org/wiki/IcedTea">IcedTea - Wikipedia</a></li>
<li><a href="https://icedtea.classpath.org/wiki/Main_Page">Main Page - IcedTea</a></li>
<li><a href="https://openjdk.java.net/projects/zero/">Zero-Assembler Project</a></li>
<li><a href="https://icedtea.classpath.org/wiki/ZeroSharkFaq">ZeroSharkFaq - IcedTea</a></li>
<li><a href="http://cr.openjdk.java.net/~ihse/docs/new-hotspot-build.html">The New Hotspot Build System</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的遍历（遍历集合或数组的几种方式）]]></title>
        <id>https://jiawanggjia.github.io/post/java-zhong-de-bian-li/</id>
        <link href="https://jiawanggjia.github.io/post/java-zhong-de-bian-li/">
        </link>
        <updated>2020-08-19T07:18:17.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要总结了<code>Java</code>中遍历集合或数组的几种方式，并介绍了各种遍历方式的实现原理，以及一些最佳实践。最后介绍了<code>Java</code>集合类迭代器的快速失败（<code>fail-fast</code>）机制。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要总结了<code>Java</code>中遍历集合或数组的几种方式，并介绍了各种遍历方式的实现原理，以及一些最佳实践。最后介绍了<code>Java</code>集合类迭代器的快速失败（<code>fail-fast</code>）机制。</p>
<!-- more -->
<h1 id="java中的循环结构">Java中的循环结构</h1>
<p>遍历必然需要使用到循环结构，<code>Java</code>中有以下几种循环结构：</p>
<ol>
<li><code>while</code>语句</li>
<li><code>do...while</code>语句</li>
<li>基本<code>for</code>语句</li>
<li>增强<code>for</code>语句</li>
</ol>
<p>对于<code>do...while</code>语句，其第一个循环体是必须会执行的，这对于空集合或者空数组是不适用的。所以我们一般不会使用<code>do...while</code>语句来进行遍历。其余三种都是我们经常用来遍历的语法结构。</p>
<blockquote>
<p><code>for</code>语句和<code>while</code>语句在一般情况下可以互相转化，下文我们并不将两种语句单独区分，会根据场景选择使用更加简单的方式。</p>
</blockquote>
<h1 id="遍历数组">遍历数组</h1>
<h2 id="1-使用下标遍历">1. 使用下标遍历</h2>
<p>使用循环遍历数组下标范围，在循环体中用下标访问数组元素：</p>
<pre><code class="language-java">for (int i = 0; i &lt; array.length; i++) {
    System.out.println(array[i]);
}
</code></pre>
<h2 id="2-增强for循环">2. 增强for循环</h2>
<p>使用增强<code>for</code>循环语法结构来对数组进行遍历：</p>
<pre><code class="language-java">for (int value : array) {
    System.out.println(value);
}
</code></pre>
<p>增强<code>for</code>循环 其实只是一种语法糖，使用 增强<code>for</code>循环 在遍历数组时，在编译过程会将其转化为 &quot;使用下标遍历&quot; 的方式，在字节码层面其实等价于第一种方式，效率上也没有太大差别。</p>
<p>关于增强<code>for</code>循环语法更详细的介绍，请移步：<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.2">Java Language Specification - 14.14.2. The enhanced for statement</a></p>
<h1 id="java中的迭代器">JAVA中的迭代器</h1>
<p>在 面向对象编程里，迭代器模式是一种设计模式，是一种最简单也最常见的设计模式。迭代器模式提供了一种方法顺序访问一个集合对象中的各个元素，而又不暴露其内部的表示。<code>Java</code>中也提供了对迭代器模式的支持，主要是针对<code>Java</code>的各种集合类进行遍历。</p>
<p><code>Iterator</code>接口是<code>Java</code>中对迭代器的抽象接口定义，其定义如下：</p>
<pre><code class="language-java">public interface Iterator&lt;E&gt; {
    // 是否还有下一个元素
    boolean hasNext();
    // 返回下一个元素
    E next();
    // 删除迭代过程中最近访问的一个元素
    // 也就是在next()之后调用remove()删除刚刚next()返回的元素
    default void remove() {
        throw new UnsupportedOperationException(&quot;remove&quot;);
    }
}
</code></pre>
<p><code>Iterable</code>接口是在<code>Java 1.5</code>中引入的，为了用来支持增强型<code>for</code>循环，只有实现了<code>Iterable</code>接口的对象才可以使用增强型<code>for</code>循环。<code>Iterable</code>接口定义如下：</p>
<pre><code class="language-java">public interface Iterable&lt;T&gt; {
    // 返回迭代器
    Iterator&lt;T&gt; iterator();
    // 使用函数式接口对增强型for循环进行包装，可以方便地使用lambda表达式来进行遍历
    default void forEach(Consumer&lt;? super T&gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
}
</code></pre>
<p>可以看到<code>Iterable</code>接口提供了<code>forEach</code>方法的默认实现，函数参数是一个函数式接口<code>action</code>参数来表示对遍历到的每个元素的操作行为，实现逻辑是使用 增强<code>for</code>循环 遍历自身，循环中对每个元素都应用 参数<code>action</code>所表示的操作行为。</p>
<h1 id="遍历list">遍历List</h1>
<h2 id="list接口的定义">List接口的定义</h2>
<p><code>List</code>表示的是一个有序的元素集合。<code>List</code>接口继承了<code>Collection</code>接口，<code>Collection</code>接口又继承了<code>Iterable</code>接口，其定义如下：</p>
<pre><code class="language-java">public interface Iterable&lt;T&gt; {
    // 返回Iterator迭代器
    Iterator&lt;T&gt; iterator();
}
public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {
}
public interface List&lt;E&gt; extends Collection&lt;E&gt; {
    // 获取指定位置的元素
    E get(int index);
    // 获取ListIterator迭代器
    ListIterator&lt;E&gt; listIterator();
    // 从指定位置获取ListIterator迭代器
    ListIterator&lt;E&gt; listIterator(int index);
}
</code></pre>
<p>可以看到<code>List</code>除了可以通过<code>iterator()</code>方法获得<code>Iterator</code>迭代器之外，还可以通过<code>listIterator()</code>方法获得<code>ListIterator</code>迭代器。<code>ListIterator</code>迭代器相比于<code>Iterator</code>迭代器之外，访问和操作元素的方法更加丰富：</p>
<ol>
<li><code>Iterator</code>只能向后迭代，而<code>ListIterator</code>可以向两个方向迭代</li>
<li><code>Iterator</code>只能在迭代过程中删除元素，而<code>ListIterator</code>可以添加元素、删除元素、修改元素。</li>
</ol>
<pre><code class="language-java">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {
    // Query Operations
    // 是否还有后一个元素
    boolean hasNext();
    // 访问后一个元素
    E next();
    // 是否还有前一个元素
    boolean hasPrevious();
    // 访问前一个元素
    E previous();
    // 后一个元素的下标
    int nextIndex();
    // 前一个元素的下标
    int previousIndex();

    // Modification Operations
    // 删除元素
    void remove();
    // 修改元素
    void set(E e);
    // 添加元素      
    void add(E e);
}
</code></pre>
<h2 id="list的遍历方法">List的遍历方法</h2>
<h3 id="1-使用下标遍历-2">1. 使用下标遍历</h3>
<p><code>List</code>接口提供了<code>get</code>方法来访问指定位置的元素，所以与遍历数组一样，<code>List</code>也可以通过遍历<code>List</code>下标并使用<code>get</code>方法访问元素来遍历<code>List</code>：</p>
<pre><code class="language-java">for (int i = 0; i &lt; list.size(); i++) {
    System.out.println(list.get(i));
}
</code></pre>
<h3 id="2-使用iterator迭代器">2. 使用Iterator迭代器</h3>
<p><code>List</code>可以使用继承自<code>Iterable</code>接口的<code>iterator()</code>方法来获得<code>Iterator</code>迭代器，使用<code>Iterator</code>迭代器来遍历<code>List</code>：</p>
<pre><code class="language-java">Iterator&lt;Integer&gt; iterator = list.iterator();
while (iterator.hasNext()){
    System.out.println(iterator.next());
}
</code></pre>
<h3 id="3-使用listiterator迭代器">3. 使用ListIterator迭代器</h3>
<p><code>List</code>还可以使用<code>listIterator()</code>方法来获得<code>ListIterator</code>迭代器，使用<code>ListIterator</code>迭代器来遍历<code>List</code>：</p>
<pre><code class="language-java">ListIterator&lt;Integer&gt; listIterator = list.listIterator();
while (listIterator.hasNext()){
    System.out.println(listIterator.next());
}
// ListIterator 可以向前遍历
listIterator = list.listIterator(list.size() - 1);
while (listIterator.hasPrevious()){
    System.out.println(listIterator.previous());
}
</code></pre>
<h3 id="4-增强for循环">4. 增强for循环</h3>
<p>我们前面说到，实现了<code>Iterable</code>接口的对象可以使用增强<code>for</code>循环遍历。<code>List</code>接口继承自<code>Iterable</code>接口，所以可以使用增强<code>for</code>循环来遍历<code>List</code>：</p>
<pre><code class="language-java">for (Integer value : list) {
    System.out.println(value);
}
</code></pre>
<p>增强性<code>for</code>循环是一种语法糖，但是与遍历数组不一样的是，使用增强型<code>for</code>循环在遍历实现了<code>Iterable</code>接口的对象时，会在编译过程中将其转化为使用<code>Iterator</code>迭代器进行遍历的方式。所以这种方式本质上与上一种方式是一样的。</p>
<p>关于增强<code>for</code>循环语法更详细的介绍，请移步：<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.2">Java Language Specification - 14.14.2. The enhanced for statement</a></p>
<h3 id="5-iterable接口的foreach方法">5. Iterable接口的forEach方法</h3>
<p>List接口实现了<code>Iterable</code>接口，<code>Iterable</code>接口中提供了<code>forEach</code>方法来更加方便的遍历集合。其参数是一个函数式接口<code>action</code>，来表示对遍历到的每个元素的操作行为。并且因为参数是一个函数式接口，所以我们可以使用<code>lamdba</code>表达式更简洁的表达遍历过程。</p>
<p><code>Iterable</code>接口的<code>forEach</code>方法的默认实现是使用增强<code>for</code>循环来遍历自身。所以如果没有重写<code>forEach</code>方法的话，这种方式本质上与上一种方式是一样的。</p>
<pre><code class="language-java">list.forEach(value -&gt; System.out.println(value));
list.forEach(System.out::println);
</code></pre>
<h2 id="最佳实践">最佳实践</h2>
<p>上面几种方式其实本质上来讲只有两种方式：</p>
<ol>
<li>使用循环遍历集合的下标范围，配合<code>get</code>方法获取集合元素 来遍历<code>List</code>。</li>
<li>使用迭代器（<code>Iterator</code>或<code>ListIterator</code>）来遍历<code>List</code>。</li>
</ol>
<p>其余方式都只不过是第二种方式的语法糖或其变种。<br>
那么到底应该使用哪种方式更好呢？这取决于<code>List</code>的内部实现方式。</p>
<p><code>List</code>的常用实现数据结构有两种，<code>数组</code>和<code>链表</code>：</p>
<ol>
<li>对于数组实现的<code>List</code>及其对应的<code>Iterator</code>/<code>ListIterator</code>实现来说，比如<code>ArrayList</code>、<code>Vector</code>。<code>List.get()</code>方法、<code>Iterator.next()</code>方法、<code>ListIterator.next()</code>方法、<code>ListIterator.previous()</code>方法的时间复杂度都为<code>O(1)</code>。所以使用下标遍历所有元素的时间复杂度为<code>O(N)</code>，使用迭代器遍历所有元素的时间复杂度也为<code>O(N)</code>。但是下标遍历的方式执行的代码更少更简单，所以效率稍高。</li>
<li>而对于链表实现的<code>List</code>其对应的<code>Iterator</code>/<code>ListIterator</code>实现来说，<code>List.get()</code>方法的时间复杂度为<code>O(N)</code>，<code>Iterator.next()</code>方法、<code>ListIterator.next()</code>方法、<code>ListIterator.previous()</code>方法的时间复杂度都为<code>O(1)</code>。所以使用下标遍历所有元素的时间复杂度为<code>O(N*N)</code>，使用迭代器遍历所有元素的时间复杂度为<code>O(N)</code>。所以使用迭代器遍历效率更高。</li>
</ol>
<p><code>Java</code>集合框架中，提供了一个<code>RandomAccess</code>接口，该接口没有方法，只是一个标记。通常被<code>List</code>接口的实现类使用，用来标记该<code>List</code>的实现类是否支持<code>Random Access</code>。一个集合类实现了该接口，就意味着它支持<code>Random Access</code>，按位置读取元素的平均时间复杂度为<code>O(1)</code>，比如<code>ArrayList</code>。而没有实现该接口的，就表示不支持<code>Random Access</code>，比如<code>LinkedList</code>。所以推荐的做法就是，如果想要遍历一个<code>List</code>，<strong>如果其实现了<code>RandomAccess</code>接口，那么使用下标遍历效率更高，否则的话使用迭代器遍历效率更高</strong>。</p>
<h1 id="遍历set">遍历Set</h1>
<h2 id="set接口的定义">Set接口的定义</h2>
<pre><code class="language-java">public interface Iterable&lt;T&gt; {
    // 返回Iterator迭代器
    Iterator&lt;T&gt; iterator();
}
public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; { }
public interface Set&lt;E&gt; extends Collection&lt;E&gt; { }
</code></pre>
<h2 id="set的遍历方法">Set的遍历方法</h2>
<p>相较于<code>List</code>，<code>Set</code>是无序的，所以<code>Set</code>没有通过下标获取元素的<code>get</code>方法，也就没办法使用下标来遍历。<code>Set</code>也没有类似<code>ListIterator</code>一样特殊的迭代器。所以遍历<code>Set</code>只能使用<code>Iterator</code>迭代器来遍历。下面三种方式其实本质上都是使用<code>Iterator</code>迭代器来遍历，后两种方式只是第一种方式的语法糖或者变种。</p>
<h3 id="1-使用iterator迭代器">1. 使用Iterator迭代器</h3>
<p><code>Set</code>接口同样继承了<code>Iterable</code>的<code>iterator()</code>方法，可以使用其返回的<code>Iterator</code>迭代器来遍历<code>Set</code>：</p>
<pre><code class="language-java">Iterator&lt;Integer&gt; iterator = set.iterator();
while (iterator.hasNext()){
    System.out.println(iterator.next());
}
</code></pre>
<h3 id="2-增强for循环-2">2. 增强for循环</h3>
<p><code>Set</code>接口实现了<code>Iterable</code>接口，所以也可以使用增强型<code>for</code>循环来遍历<code>Set</code>：</p>
<pre><code class="language-java">for (Integer value : set) {
    System.out.println(value);
}
</code></pre>
<h3 id="3-iterable接口的foreach方法">3. Iterable接口的forEach方法</h3>
<p><code>Set</code>接口实现了<code>Iterable</code>接口，所以也可以使用<code>forEach</code>方法来遍历<code>Set</code>：</p>
<pre><code class="language-java">set.forEach(value -&gt; System.out.println(value));
set.forEach(System.out::println);
</code></pre>
<h1 id="遍历map">遍历Map</h1>
<p>不同于<code>List</code>，<code>Map</code>并不是一组元素的集合，而是一组键值对，所以<code>Map</code>没有继承<code>Collection</code>、<code>Iterable</code>等其他接口。</p>
<h2 id="map接口的定义">Map接口的定义</h2>
<pre><code class="language-java">public interface Map&lt;K,V&gt; {
    // 返回Map中键的集合
    Set&lt;K&gt; keySet();
    // 返回Map中值的集合
    Collection&lt;V&gt; values();
    // 返回Map中键值对的集合
    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();
    // 类似于Iterable接口的forEach方法
    default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
        Objects.requireNonNull(action);
        for (Map.Entry&lt;K, V&gt; entry : entrySet()) {
            K k;
            V v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch(IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
            action.accept(k, v);
        }
    }
}
</code></pre>
<p><code>Map</code>提供了<code>keySet()</code>、<code>values()</code>、<code>entrySet()</code>方法来分别获取<code>Map</code>的 键集合、值集合、键值对集合。并且提供了类似于<code>Iterable</code>的<code>forEach</code>方法及其默认实现。</p>
<h2 id="map的遍历方法">Map的遍历方法</h2>
<p>遍历<code>Map</code>可以通过先获取其 键集合、值集合、键值对集合，然后根据返回的集合类型选择不同的遍历方式。</p>
<p>同时，<code>Map</code>也提供了类似于<code>Iterable</code>的<code>forEach</code>方法，参数<code>action</code>是一个函数式接口，指定了对于每一个键值对的操作行为，实现逻辑是使用增强<code>for</code>循环遍历<code>Map</code>的<code>entrySet()</code>方法的返回值，对于每一个遍历到的每一个键值对，应用参数<code>action</code>代表的操作行为。</p>
<h1 id="java集合中的快速失败机制">Java集合中的快速失败机制</h1>
<h2 id="何为快速失败">何为快速失败</h2>
<p><a href="https://en.wikipedia.org/wiki/Fail-fast">wikipedia</a>上对<code>快速失败（fail-fast）</code>的介绍是：</p>
<blockquote>
<p>In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process.</p>
</blockquote>
<p>简单来说就是系统运行中，如果有错误发生，那么系统立即结束，而不是继续冒不确定的风险继续执行，这种设计就是&quot;<strong>快速失败</strong>&quot;。</p>
<h2 id="java集合迭代器的快速失败机制">Java集合迭代器的快速失败机制</h2>
<p><code>Java</code>集合框架中的一些集合类的迭代器也是被设计为<code>快速失败</code>的。集合迭代器中的快速失败机制是说：</p>
<blockquote>
<p>在使用迭代器遍历集合时，如果迭代器创建之后，通过 除了迭代器提供的修改方法之外 的其他方式对集合进行了结构性修改（添加、删除元素等），那么迭代器应该抛出一个<code>ConcurrentModificationException</code>异常，表示在此次遍历中集合发生了&quot;并发修改&quot;，应该提前终止迭代过程。因为在迭代器遍历集合的过程中，如果有别的行为改变了集合本身的结构，那么迭代器之后的行为可能就是不符合预期的，可能会出现错误的结果，所以提前检测并抛出异常是一个更好的做法。</p>
</blockquote>
<p><code>Java</code>中大部分基本的集合类的迭代器都实现了快速失败机制，包括<code>ArrayList</code>，<code>LinkedList</code>，<code>Vector</code>，<code>HashMap</code>，<code>HashSet</code>等等。但是对于并发集合类，例如<code>ConcurrentHashMap</code>，<code>CopyOnWriteArrayList</code>等，这些类本身就是设计来支持并发的，是线程安全的，所以也不存在快速失败这一说。</p>
<p>以<code>ArrayList</code>为例，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList (Java Platform SE 8 )</a>中对<code>fail-fast</code>的介绍如下：</p>
<blockquote>
<p>The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</p>
</blockquote>
<blockquote>
<p><code>ArrayList</code>的<code>iterator</code>和<code>listIterator</code>方法返回的迭代器都是<code>fail-fast</code>的：如果在迭代器创建之后，通过除了迭代器自身的<code>add</code>/<code>remove</code>方法之外的其他方式，对<code>ArrayList</code>进行了结构性修改（添加、删除元素等），那么该迭代器应该抛出一个<code>ConcurrentModificationException</code>异常。所以，迭代器在面对并发修改时，迭代器将快速而干净地失败，而不是冒着在未来不确定的时间发生不确定行为的风险继续执行。</p>
</blockquote>
<h2 id="典型实践">典型实践</h2>
<p>如果看过阿里的《JAVA开发手册》，会知道里面有这一条规范：</p>
<blockquote>
<p>【强制】不要在 <code>foreach</code> 循环里进行元素的 <code>remove</code>/<code>add</code> 操作。<code>remove</code> 元素请使用 <code>Iterator</code>方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p>
</blockquote>
<p>上面说的<code>foreach</code>循环指的上面我们提到的使用增强<code>for</code>循环进行遍历的方式。这种方式本质上使用的是迭代器方式。所以更明确一点，这个规范其实就是在说：</p>
<blockquote>
<p>在使用<code>Iterator</code>迭代器遍历集合过程中，不要通过集合本身的<code>remove</code>/<code>add</code>方法来进行元素的 <code>remove</code>/<code>add</code> 操作，<code>remove</code>请使用<code>Iterator</code>提供的<code>remove</code>方法。</p>
</blockquote>
<p><strong>正确</strong>方式：</p>
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(3);
Iterator&lt;Integer&gt; iterator = list.iterator();
while (iterator.hasNext()) {
    Integer item = iterator.next();
    if (item == 1) {
        iterator.remove();
    }
}
list.forEach(System.out::println); // 输出 2 3 
</code></pre>
<p><strong>错误</strong>方式：</p>
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(3);
for (Integer item : list) {  // 会在这里抛出异常
    if (item == 1) {
        list.remove(item);  // 使用 list.remove 删除
    }
}
list.forEach(System.out::println);
</code></pre>
<p>上述代码会在第五行抛出<code>java.util.ConcurrentModificationException</code>异常。因为其本质还是使用迭代器遍历，所以为了方便理解其原因，我们将上述方式改写为：</p>
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(3);
Iterator&lt;Integer&gt; iterator = list.iterator();
while (iterator.hasNext()) {
    Integer item = iterator.next();  // 会在这里抛出异常
    if (item == 1) {
        list.remove(item);  // 使用 list.remove 删除
    }
}
list.forEach(System.out::println);
</code></pre>
<p>这段代码会在第<code>7</code>行抛出<code>java.util.ConcurrentModificationException</code>异常。与第一种方式的差别仅仅在于使用了<code>List.remove</code>方法而不是<code>Iterator.remove</code>方法。</p>
<h2 id="快速失败的实现原理">快速失败的实现原理</h2>
<p>以<code>ArrayList</code>为例来说明快速失败机制的实现原理，其他类的实现方式也是大致相同的。</p>
<ol>
<li><code>ArrayList</code>中有一个属性<code>modCount</code>，是一个记录<code>ArrayList</code>修改次数的计数器。</li>
<li><code>ArrayList</code>的<code>iterator</code>/<code>listIterator</code>方法被调用时，会创建出<code>Iteartor</code>/<code>ListIterator</code>的实现类 <code>ArrayList.Itr</code>/<code>ArrayList.ListItr</code>迭代器对象，其中有一个属性<code>expectedModCount</code>。当迭代器被创建时，<code>ArrayList</code>本身的<code>modCount</code>将被复制给<code>Itr</code>/<code>ListItr</code>中的<code>expectedModCount</code>属性。</li>
<li>当使用迭代器的<code>remove</code>/<code>add</code>方法增删元素时，在修改<code>ArrayList</code>的<code>modCount</code>之后，还会将其值复制给迭代器自身的<code>expectedModCount</code>。而通过<code>ArrayList</code>的<code>remove</code>/<code>add</code>方法增删元素时，仅仅修改了<code>ArrayList</code>的<code>modCount</code>。</li>
<li>当迭代器执行<code>next</code>/<code>remove</code>/<code>add</code>/<code>set</code>操作时是会检查迭代器自身的<code>expectedModCount</code>与<code>ArrayList</code>的<code>modCount</code>是否相等，如果不相等则会抛出<code>ConcurrentModificationException</code>异常。</li>
</ol>
<p>所以在迭代过程中，如果只使用迭代器的<code>remove</code>/<code>add</code>方法增删元素，是不会出现问题的，因为在增删元素之后迭代器始终会将<code>ArrayList</code>的<code>modCount</code>值赋值给迭代器自身的<code>expectedModCount</code>，所以下次迭代两者一定相等。而如果迭代过程中使用了<code>ArrayList</code>的<code>remove</code>/<code>add</code>方法增删元素，或者有另外一个迭代器进行了增删元素，就会造成<code>ArrayList</code>中的<code>modCount</code>与迭代器中的<code>expectedModCount</code>不一致，抛出<code>ConcurrentModificationException</code>异常。</p>
<h2 id="快速失败的bug">快速失败的&quot;bug&quot;</h2>
<p>快速失败机制也不能够保证百分之百生效，例如，在下面这段代码中，使用迭代器遍历<code>ArrayList</code>过程中，使用<code>ArrayList</code>的<code>remove</code>方法删除倒数第二个元素，程序能够正确删除，并不会像我们上面所说的抛出<code>ConcurrentModificationException</code>异常。</p>
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(1);
list.add(2);
list.add(3);
Iterator&lt;Integer&gt; iterator = list.iterator();
while (iterator.hasNext()) {
    Integer item = iterator.next();
    if (item == 2) {
        list.remove(item);
    }
}
list.forEach(System.out::println);  // 输出 1 3
</code></pre>
<p>这个&quot;<code>bug</code>&quot;发生的原因在于，在第二次执行<code>iterator.next()</code>后，迭代器记录的下一次将要访问的下标应该是<code>2</code>，而在执行<code>list.remove()</code>删除元素后，<code>list</code>的<code>size</code>变为了<code>2</code>，所以在下次执行<code>iterator.hasNext()</code>时认为已经没有元素要继续迭代了，返回<code>false</code>，结束循环。</p>
<p>所以<code>fail-fast</code>机制并不能够完全保证所有的并发修改的情况都抛出<code>ConcurrentModificationException</code>异常，在程序中也不应该依赖于这个异常信息。<br>
在<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList (Java Platform SE 8 )</a>中也指出了<code>fail-fast</code>这一性质：</p>
<blockquote>
<p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.</p>
</blockquote>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.2">The Java Language Specification, Java SE 8 Edition</a></li>
<li><a href="https://blog.csdn.net/HJF_HUANGJINFU/article/details/51220253#t23">Java遍历集合的几种方法分析（实现原理、算法性能、适用场合）</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList (Java Platform SE 8 )</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL 5.7 编译调试指南(Ubuntu 16.04 + MacOS 10.15)]]></title>
        <id>https://jiawanggjia.github.io/post/mysql-57-bian-yi-diao-shi-zhi-nan-ubuntu-1604-macos-1015/</id>
        <link href="https://jiawanggjia.github.io/post/mysql-57-bian-yi-diao-shi-zhi-nan-ubuntu-1604-macos-1015/">
        </link>
        <updated>2020-07-29T16:44:37.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要介绍在<code>MacOS 10.15</code>和<code>Ubuntu 16.04</code>系统下编译构建<code>MySQL 5.7.30</code>并使用<code>JetBrains CLion</code>(以下简称<code>CLion</code>)进行运行调试的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要介绍在<code>MacOS 10.15</code>和<code>Ubuntu 16.04</code>系统下编译构建<code>MySQL 5.7.30</code>并使用<code>JetBrains CLion</code>(以下简称<code>CLion</code>)进行运行调试的方法。</p>
<!-- more -->
<h1 id="下载源码">下载源码</h1>
<p>可以从两种方式下载<code>MySQL</code>源代码：</p>
<h2 id="从官方代码库下载最新源代码">从官方代码库下载最新源代码</h2>
<pre><code class="language-bash"># clone过程可能耗时比较长
git clone https://github.com/mysql/mysql-server.git
# 可以切换至指定版本对应分支
git checkout 5.7
</code></pre>
<h2 id="下载源代码分发包">下载源代码分发包</h2>
<p><code>MySQL</code>提供了各个版本的源码分发包供下载。下载地址：<a href="https://downloads.mysql.com/archives/community/">MySQL Product Archives</a>，选择指定版本下载解压即可。</p>
<h1 id="安装依赖">安装依赖</h1>
<p>对于各个依赖或者工具，安装前可以先验证一下是否已经安装，一些工具系统已经预装。</p>
<h2 id="1-构建工具-cmake-make">1. 构建工具 CMake + make</h2>
<p>在<code>Ubuntu</code>上：</p>
<pre><code class="language-bash">sudo apt install cmake make
</code></pre>
<p>在<code>MacOS</code>上：</p>
<pre><code class="language-bash">brew install cmake make
</code></pre>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/source-installation-prerequisites.html">MySQL 5.7 Reference Manual</a>建议的<code>make</code>为<code>GNU make 3.75</code>或者更高版本。</p>
<h2 id="2-编译工具-gccclang">2. 编译工具 GCC/Clang</h2>
<p>在<code>Ubuntu</code>上，<code>MySQL</code>可以使用<code>GCC</code>或者<code>Clang</code>来编译，这里我们使用<code>apt</code>来安装<code>GCC</code>：</p>
<pre><code class="language-bash">sudo apt install gcc
</code></pre>
<p>在<code>MacOS</code>上，<code>MySQL</code>会使用<code>Clang</code>编译器来编译，一般<code>MacOS</code>系统已经安装好了<code>Clang</code>，如果没有的的话可以通过安装<code>Xcode</code>来方便地安装<code>Clang</code>。可以在<code>App Store</code>中下载完整<code>Xcode</code>，或者使用如下命令来安装<code>Xcode command line tools</code>：</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<p>根据<a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html#option_cmake_force_unsupported_compiler">MySQL 5.7 Reference Manual</a>，对于<code>MySQL 5.7</code>，支持的<code>GCC</code>最低版本是<code>4.4</code>，支持的<code>Clang</code>最低版本是<code>3.3</code>。</p>
<h2 id="3-openssl">3. OpenSSL</h2>
<p>在<code>Ubuntu</code>下：</p>
<pre><code class="language-bash">sudo apt install openssl libssl-dev
</code></pre>
<p>在<code>MacOS</code>下：</p>
<pre><code class="language-bash">brew install openssl
</code></pre>
<p>根据<a href="https://dev.mysql.com/doc/refman/5.7/en/source-ssl-library-configuration.html">MySQL 5.7 Reference Manual</a>，对于<code>MySQL 5.7</code>，支持的最小<code>OpenSSL</code>版本是<code>1.0.1</code>。</p>
<h2 id="4-boost">4. Boost</h2>
<p>根据<a href="https://dev.mysql.com/doc/refman/5.7/en/source-installation-prerequisites.html">MySQL 5.7 Reference Manual</a>，对于<code>MySQL 5.7</code>，必须要使用<code>1.59.0</code>版本。在<a href="https://www.boost.org/users/history/">Boost Version History</a>下载<code>Boost 1.59.0</code>并解压。</p>
<blockquote>
<p>因为<code>1.59.0</code>是比较老的版本，所以并不推荐直接使用包管理器在全局安装一个旧版本的<code>Boost</code>，所以我们这里采用下载后在构建时指定其路径的方法。</p>
</blockquote>
<h2 id="5-ncurses">5. ncurses</h2>
<p>在<code>Ubuntu</code>下：</p>
<pre><code class="language-bash">sudo apt-get install libncurses5-dev
</code></pre>
<p>在<code>MacOS</code>下：</p>
<pre><code class="language-bash">brew install ncurses
</code></pre>
<h2 id="6-bison">6. Bison</h2>
<p>在<code>Ubuntu</code>下：</p>
<pre><code class="language-bash">sudo apt-get install bison
</code></pre>
<p>在<code>MacOS</code>下：</p>
<pre><code class="language-bash">brew install bison
</code></pre>
<p>根据<a href="https://dev.mysql.com/doc/refman/5.7/en/source-installation-prerequisites.html">MySQL 5.7 Reference Manual</a>，对于<code>MySQL 5.7</code>，支持的<code>bison</code>最低版本是<code>2.1</code>，</p>
<h1 id="编译构建">编译构建</h1>
<p>为了不影响机器上原本已经安装的<code>MySQL</code>，在配置构建过程中，我们自定义了一些配置避免与机器上另外的<code>MySQL</code>实例冲突。</p>
<pre><code class="language-bash"># 进入源码目录
cd mysql-server
# 创建构建文件的目录及数据目录、临时文件目录
mkdir -p bld/data bld/tmp
# 配置，&quot;/home/jiajiawang/workspace/mysql-server/&quot;为源码目录的绝对路径
cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=/home/jiajiawang/workspace/mysql-server/bld -DMYSQL_DATADIR=/home/jiajiawang/workspace/mysql-server/bld/data  -DMYSQL_UNIX_ADDR=/home/jiajiawang/workspace/mysql-server/bld/data/mysql.sock -DTMPDIR=/home/jiajiawang/workspace/mysql-server/bld/tmp/ -DMYSQL_TCP_PORT=3336 -DWITH_BOOST=/home/jiajiawang/software/boost_1_59_0

# 构建
make
# 安装MySQL
make install
</code></pre>
<p>上面配置的目录及文件位置最好都配置成<strong>绝对路径</strong>。</p>
<p><code>CMake</code>选项说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMAKE_BUILD_TYPE</td>
<td>生成的构建类型，可选值有：<code>RelWithDebInfo</code>，<code>Debug</code> ，使用<code>Debug</code>可以禁用优化，更有助于调试</td>
<td><code>RelWithDebInfo</code></td>
</tr>
<tr>
<td>CMAKE_INSTALL_PREFIX</td>
<td>指定<code>MySQL</code>安装路径</td>
<td><code>/usr/local/mysql</code></td>
</tr>
<tr>
<td>MYSQL_DATADIR</td>
<td>指定<code>MySQL</code>数据目录</td>
<td></td>
</tr>
<tr>
<td>MYSQL_UNIX_ADDR</td>
<td>指定<code>Unix socket</code>文件目录</td>
<td><code>/tmp/mysql.sock</code></td>
</tr>
<tr>
<td>TMPDIR</td>
<td>指定临时文件目录</td>
<td></td>
</tr>
<tr>
<td>MYSQL_TCP_PORT</td>
<td><code>MySQL</code>启动<code>TCP</code>端口号</td>
<td><code>3306</code></td>
</tr>
<tr>
<td>WITH_BOOST</td>
<td>指定<code>Boost</code>依赖的路径</td>
<td></td>
</tr>
</tbody>
</table>
<p>更多选项说明请参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html">MySQL 5.7 Reference Manual</a></p>
<h1 id="配置并启动mysql">配置并启动MySQL</h1>
<h2 id="1-数据库初始化">1. 数据库初始化</h2>
<pre><code class="language-bash">cd bld
</code></pre>
<p>使用如下命令可以用来初始化数据库。两个参数的区别是<code>--initialize</code>会为<code>root@localhost</code>用户生成一个随机密码，而<code>--initialize-insecure</code>会设置<code>root@localhost</code>用户密码为空：</p>
<pre><code class="language-bash">bin/mysqld --initialize
# 或者
bin/mysqld --initialize-insecure
</code></pre>
<p>创建加密连接需要的文件：</p>
<pre><code class="language-bash">bin/mysql_ssl_rsa_setup
</code></pre>
<h2 id="2-启动-mysql-server">2. 启动 MySQL Server</h2>
<p>启动<code>MySQL Server</code>：</p>
<pre><code class="language-bash">bin/mysqld
</code></pre>
<p>关于其他启动方式，参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/programs-server.html">MySQL 5.7 Reference Manual</a></p>
<h2 id="3-使用-mysql-client-连接-server">3. 使用 MySQL Client 连接 Server</h2>
<p>使用<code>MySQL Client</code>连接<code>Server</code>：</p>
<pre><code class="language-bash"># 如果没有生成密码的话可以不指定-p
bin/mysql -uroot -p
</code></pre>
<p>使用初始化时生成的随机密码登录后需要修改密码才可以进行其他操作：</p>
<pre><code class="language-bash">alter user 'root'@'localhost' identified by 'root';
</code></pre>
<h2 id="4-关闭mysql-server">4. 关闭MySQL Server</h2>
<p>使用<code>ps</code>命令找到<code>mysqld</code>的进程ID，使用<code>kill -9 &lt;pid&gt;</code>杀掉进程。</p>
<h1 id="导入clion并运行调试">导入<code>CLion</code>并运行/调试</h1>
<ol>
<li>导入<code>CLion</code></li>
<li>设置<code>CMake</code>参数。点击<code>File</code>菜单栏，<code>Settings | Build, Execution, Deployment | CMake</code>，在<code>CMake options</code>输入框中输入上文执行<code>cmake</code>命令时的参数。<br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200726235304.png" alt="" loading="lazy"></li>
<li>运行/调试<code>MySQL</code>。点击<code>Run</code>菜单栏，<code>Edit Configurations</code>，左侧<code>CMake Application</code>列出了<code>MySQL</code>中的各个程序，例如<code>mysqld</code>为<code>MySQL Server</code>，<code>mysql</code>为<code>MySQL CLient</code>，可以在对应的<code>Program arguments</code>中配置各种参数。</li>
</ol>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/source-installation.html">Installing MySQL from Source</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/postinstallation.html">Postinstallation Setup and Testing</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html">Server Command Options</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-servers.html">Running Multiple MySQL Instances on One Machine</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用CLion调试Redis(Ubuntu 16.04 + MacOS 10.15)]]></title>
        <id>https://jiawanggjia.github.io/post/bs-IxGChu/</id>
        <link href="https://jiawanggjia.github.io/post/bs-IxGChu/">
        </link>
        <updated>2020-07-05T02:13:56.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要介绍如何编译<code>Redis</code>项目并在<code>JetBrains CLion</code>（以下简称<code>CLion</code>）中运行/调试。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要介绍如何编译<code>Redis</code>项目并在<code>JetBrains CLion</code>（以下简称<code>CLion</code>）中运行/调试。</p>
<!-- more -->
<h1 id="0-开始之前">0. 开始之前</h1>
<h2 id="json-compilation-database">JSON Compilation Database</h2>
<p><code>CLion</code>默认支持<code>CMake</code>构建的项目，但<code>Redis</code>项目是基于<code>Make</code>构建的。对于使用<code>Make</code>构建的项目，<code>CLion</code>仍然可以通过<code>Compilation Database</code>来导入项目，而不用将其修改为<code>CMake</code>项目。同时也能通过<code>Compilation Database</code>实现代码的分析、跳转等功能，这对于我们进行代码调试很有帮助。</p>
<p>有关于<code>Compilation Database</code>的介绍可以参考这几篇文章：</p>
<ul>
<li><code>Clang</code>官方的<code>Compilation Database</code>介绍页面：<a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html">JSON Compilation Database Format Specification — Clang 11 documentation</a></li>
<li>这篇文章介绍了在不同场景下生成<code>Compilation database</code>的各种工具：<a href="https://sarcasm.github.io/notes/dev/compilation-database.html">Compilation database — Sarcasm notebook</a></li>
<li><code>CLion</code>的帮助页面简要介绍了<code>Compilation Database</code>，以及在<code>CLion</code>的使用：<a href="https://www.jetbrains.com/help/clion/compilation-database.html">Compilation Database - Help | CLion</a></li>
</ul>
<p>对于基于<code>Make</code>构建的<code>Redis</code>项目来说，有一些工具可以生成<code>Compilation Database</code>，比如下面几个：</p>
<ul>
<li><a href="https://github.com/rizsotto/Bear">https://github.com/rizsotto/Bear</a></li>
<li><a href="https://github.com/rizsotto/scan-build">https://github.com/rizsotto/scan-build</a></li>
<li><a href="https://github.com/nickdiego/compiledb">https://github.com/nickdiego/compiledb</a></li>
</ul>
<p>通常默认生成的<code>Compilation Database</code>是一个<code>compile_commands.json</code>文件。</p>
<h1 id="1-下载redis源码">1. 下载Redis源码</h1>
<pre><code class="language-bash">git clone git@github.com:redis-io/redis.git
cd redis
# 可以切换至指定版本对应分支
git checkout 5.0
</code></pre>
<h1 id="2-编译构建redis">2. 编译构建Redis</h1>
<p><code>Redis</code>基于<code>Make</code>构建，执行<code>make</code>命令即可完成构建。<code>Redis</code> 默认使用<code>-O2</code>级别优化，可以使用<code>make noopt</code>来编译以关闭优化，获得更多的调试信息。</p>
<hr>
<p>我们需要使用工具来生成<code>Compilation Database</code>，以便于导入<code>CLion</code>。在不同系统上各个工具安装情况可能略有不同，下面分别介绍<code>Ubuntu 16.04</code>和<code>MacOS 10.15</code>上编译<code>Redis</code>并生成<code>Compilation Database</code>的方法。</p>
<h2 id="ubuntu-1604">Ubuntu 16.04</h2>
<h3 id="使用bear工具">使用Bear工具</h3>
<pre><code class="language-bash"># 下载Bear工具
sudo apt-get install bear
# 编译构建，并使用Bear工具生成 Compilation Database
bear make noopt
</code></pre>
<h3 id="使用compiledb工具">使用compiledb工具</h3>
<pre><code class="language-bash"># 安装pip
sudo apt-get install python-pip
# pip安装 compiledb
pip install compiledb
# 编译构建，并使用compiledb工具生成 Compilation Database
compiledb make noopt
</code></pre>
<h2 id="macos-1015">MacOS 10.15</h2>
<h3 id="使用bear工具-2">使用Bear工具</h3>
<p>在<code>MacOS</code>上使用Bear工具需要关闭SIP，关闭方法是进入恢复模式执行<code>csrutil disable</code>命令，然后重启，详细操作方法请自行搜索。</p>
<p>我们需要用到<code>Homebrew</code>来安装<code>Bear</code>，如果没有安装<code>Homebrew</code>需要先安装<code>Homebrew</code>，安装方法：</p>
<pre><code class="language-bash">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;
</code></pre>
<p>开始编译<code>Redis</code>：</p>
<pre><code class="language-bash"># 下载Bear工具
brew install bear
# 编译构建，并使用Bear工具生成 Compilation Database
bear make noopt
</code></pre>
<p>如果遇到<code>adlist.c:32:10: fatal error: 'stdlib.h' file not found</code>报错，可以先执行以下命令后重试：</p>
<pre><code class="language-bash">sudo mount -uw /
sudo cp -R /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include /usr
</code></pre>
<h3 id="使用compiledb工具-2">使用compiledb工具</h3>
<p>我们需要使用<code>pip</code>来安装<code>compiledb</code>，如果没有安装<code>pip</code>需要先安装<code>pip</code>，安装方法：</p>
<pre><code class="language-bash">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
python get-pip.py
# 安装pip之后可能还需要设置环境变量
</code></pre>
<p>开始编译<code>Redis</code>：</p>
<pre><code class="language-bash"># pip安装 compiledb
pip install compiledb
# 编译构建，并使用compiledb工具生成 Compilation Database
compiledb make noopt
</code></pre>
<hr>
<p>编译完成之后可以检验以下是否成功：</p>
<pre><code>$ ./src/redis-server --version
Redis server v=5.0.8 sha=1f7d08b7:1 malloc=libc bits=64 build=3530fd9b48a55c7f
</code></pre>
<p>同时根目录下应该会有一个不为空的<code>compile_commands.json</code>文件。</p>
<h2 id="导入clion并调试">导入CLion并调试</h2>
<p>对于如何在<code>CLion</code>中管理基于<code>Make</code>构建的项目，<code>CLion</code>的官方帮助文档中有详细的介绍：<br>
<a href="https://www.jetbrains.com/help/clion/managing-makefile-projects.html">Managing Makefile Projects</a>。参考上述文档，本小节简要介绍了如何在<code>CLion</code>中导入<code>Redis</code>项目并运行/调试的方法。</p>
<ol>
<li>
<p>下载安装<code>CLion</code>，并安装<code>Makefile Support</code>插件。建议使用最新版本，较老的版本是不支持<code>Make</code>构建的项目的。</p>
</li>
<li>
<p>导入项目。打开<code>CLion</code>，选择<code>Open Or Import</code>，选择项目目录中的<code>compile_commands.json</code>文件，弹出框选择<code>Open as Project</code>，等待文件索引完成。<br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200705183609.gif" alt="" loading="lazy"></p>
</li>
<li>
<p>创建自定义<code>Build Target</code>。点击<code>File</code>菜单栏，<code>Settings | Build, Execution, Deployment | Custom Build Targets</code>，点击<code>+</code>新建一个<code>Target</code>。</p>
<ul>
<li><code>Name</code>：<code>Target</code>的名字，之后在创建<code>Run/Debug</code>配置的时候会看到这个名字</li>
<li>点击<code>Build</code>或者<code>Clean</code>右边的三点，弹出框中点击<code>+</code>新建两个<code>External Tool</code>配置如下：<br>
第一个配置如下，用来指定构建指令，Program 和 Arguments 共同构成了所要执行的命令 &quot;make noopt&quot;<pre><code class="language-bash">Name: make
Program: make
Arguments: noopt
Working directory: $ProjectFileDir$
</code></pre>
第二个配置如下，用来清理构建输出，Program 和 Arguments 共同构成了所要执行的命令 &quot;make clean&quot;<pre><code class="language-bash">Name: make clean
Program: make
Arguments: clean
Working directory: $ProjectFileDir$
</code></pre>
</li>
<li><code>ToolChain</code>选择<code>Default</code>；<code>Build</code>选择<code>make</code>（上面创建的第一个<code>External Tool</code>）；<code>Clean</code>选择<code>make clean</code>（上面创建的第二个<code>External Tool</code>）<br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200705183311.gif" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p>创建自定义的<code>Run/Debug configuration</code>。点击<code>Run</code>菜单栏,<code>Edit Configurations</code>， 点击<code>+</code>，选择<code>Custom Build Application</code>，配置如下：</p>
<pre><code class="language-bash"># Name：Configure 的名称
Name: redis
# Target：选择上一步创建的 “Custom Build Target”
Target: redis
# Executable：程序执行入口，也就是需要调试的程序
Executable: 这里我们调试Redis Server，选择`{source_root}/src/redis-server`。
# Program arguments: 与 “Executable” 配合使用，指定其参数
Program arguments: 这里我们选择&quot;$ProjectFileDir$/redis.conf&quot;作为配置文件启动Redis服务器
</code></pre>
<p><code>Executable</code>和<code>Program arguments</code>可以根据需要调试的信息自行设置。</p>
<p>如果不想每次运行/调试前都执行<code>Build</code>操作（在这里就是<code>Make</code>构建过程），可以在编辑页下方<code>Before launch</code>框中删除<code>Build</code>条目。<br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200705183322.gif" alt="" loading="lazy"></p>
</li>
<li>
<p>点击<code>Run</code>/<code>Debug</code>开始运行/调试。</p>
</li>
</ol>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://redis.io/topics/debugging">Redis debugging guide</a></li>
<li><a href="https://github.com/nickdiego/compiledb">nickdiego/compiledb: Tool for generating Clang's JSON Compilation Database files for make-based build systems.</a></li>
<li><a href="https://www.jetbrains.com/help/clion/managing-makefile-projects.html">Managing Makefile Projects</a></li>
<li><a href="https://blog.jetbrains.com/clion/2020/02/dealing-with-makefiles/">Dealing with Makefile Projects in CLion: Status Update</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenJDK 编译指南(Ubuntu 16.04 + MacOS 10.15)]]></title>
        <id>https://jiawanggjia.github.io/post/openjdk-bian-yi-zhi-nan/</id>
        <link href="https://jiawanggjia.github.io/post/openjdk-bian-yi-zhi-nan/">
        </link>
        <updated>2020-06-28T01:14:56.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇文章主要介绍在<code>MacOS</code>系统和<code>Ubuntu</code>系统上如何编译<code>OpenJDK</code>项目代码，并使用<code>IDE</code>工具<code>JetBrains CLion</code>（下文简称<code>CLion</code>）来运行/调试<code>OpenJDK</code>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇文章主要介绍在<code>MacOS</code>系统和<code>Ubuntu</code>系统上如何编译<code>OpenJDK</code>项目代码，并使用<code>IDE</code>工具<code>JetBrains CLion</code>（下文简称<code>CLion</code>）来运行/调试<code>OpenJDK</code>。</p>
<!-- more -->
<p>文中仅包含两种操作系统的特定版本（<code>MacOS 10.15</code>和<code>Ubuntu 16.04</code>）下的方法，不同版本下可能会略有差异。希望对读者有一定的参考价值。</p>
<p>总体来说，编译<code>OpenJDK11</code>在两种系统上都没有太大的阻碍，难度低于<code>OpenJDK8</code>。编译<code>OpenJDK8</code>在<code>Ubuntu</code>上比较简单，在<code>MacOS</code>上比较繁琐复杂。</p>
<h1 id="编译调试openjdk的基本步骤">编译调试OpenJDK的基本步骤</h1>
<p>完成编译并实现调试<code>OpenJDK</code>流程可以分为以下几个步骤：</p>
<ol>
<li>获取<code>OpenJDK</code>项目源代码</li>
<li>下载一个合适版本的<code>JDK</code>作为<code>BootJDK</code></li>
<li>下载所需工具链，包括编译器、调试器、构建工具等</li>
<li>下载所需依赖库</li>
<li><code>Running Configure</code>（配置）</li>
<li><code>Running Make</code>（构建）</li>
<li>导入<code>CLion</code>并进行<code>Run/Debug</code>配置</li>
</ol>
<p>其中3-6步对于不同操作系统和不同<code>OpenJDK</code>版本差异较大，其余步骤差异较小，所以本文的行文顺序是先将1-2、7三部分以及一些前置知识做详细介绍。在之后的具体场景（不同操作系统 + 不同<code>OpenJDK</code>版本）中针对对这些部分只做差异点的特殊说明。</p>
<h1 id="开始之前">开始之前</h1>
<h2 id="如何获取-openjdk-源代码">如何获取 OpenJDK 源代码？</h2>
<p>编译调试的第一步当然是获取到<code>OpenJDK</code>的源代码，获取方式主要有以下三种：</p>
<h3 id="1-通过openjdk官方的mercurial仓库下载">1. 通过<code>OpenJDK</code>官方的<code>Mercurial</code>仓库下载</h3>
<p><code>OpenJDK</code>官方使用<code>Mercurial</code>来进行版本控制。<code>Mercurial</code>仓库地址：<a href="http://hg.openjdk.java.net/">http://hg.openjdk.java.net/</a>，主要项目地址：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>jdk</td>
<td><a href="http://hg.openjdk.java.net/jdk/jdk">http://hg.openjdk.java.net/jdk/jdk</a></td>
</tr>
<tr>
<td>jdk8u</td>
<td><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/">http://hg.openjdk.java.net/jdk8u/jdk8u/</a></td>
</tr>
<tr>
<td>jdk11u</td>
<td><a href="https://hg.openjdk.java.net/jdk-updates/jdk11u/">https://hg.openjdk.java.net/jdk-updates/jdk11u/</a></td>
</tr>
</tbody>
</table>
<p>通过这种方式下载源代码，需要先安装<code>Mercurial</code>工具，并使用<code>hg clone &lt;url&gt;</code>下载源代码。比如下载	<code>jdk8u</code>使用如下命令：</p>
<pre><code class="language-bash">hg clone http://hg.openjdk.java.net/jdk8u/jdk8u/
</code></pre>
<p>这种方式下载比较慢，而且会有中断的情况，<strong>不推荐使用</strong>。</p>
<h3 id="2-通过镜像git仓库下载">2. 通过镜像<code>Git</code>仓库下载</h3>
<p>OpenJDK官方在<code>GitHub</code>上有JDK项目的仓库镜像，主页地址：<a href="https://github.com/openjdk">https://github.com/openjdk</a>，主要项目地址：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>jdk</td>
<td><a href="https://github.com/openjdk/jdk">https://github.com/openjdk/jdk</a></td>
</tr>
<tr>
<td>jdk11u</td>
<td><a href="https://github.com/openjdk/jdk11u">https://github.com/openjdk/jdk11u</a></td>
</tr>
<tr>
<td>jdk12u</td>
<td><a href="https://github.com/openjdk/jdk12u">https://github.com/openjdk/jdk12u</a></td>
</tr>
</tbody>
</table>
<p>但在官方<code>git</code>仓库中没有看到 <code>jdk11</code> 以下的版本。</p>
<p>除此之外还有一些非官方的镜像<code>Git</code>仓库。比如<code>AdoptOpenJDK</code>项目，主页地址：<a href="https://github.com/AdoptOpenJDK/">https://github.com/AdoptOpenJDK/</a>，主要项目地址：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>jdk</td>
<td><a href="https://github.com/AdoptOpenJDK/openjdk-jdk">https://github.com/AdoptOpenJDK/openjdk-jdk</a></td>
</tr>
<tr>
<td>jdk8u</td>
<td><a href="https://github.com/AdoptOpenJDK/openjdk-jdk8u">https://github.com/AdoptOpenJDK/openjdk-jdk8u</a></td>
</tr>
<tr>
<td>jdk11u</td>
<td><a href="https://github.com/AdoptOpenJDK/openjdk-jdk11u">https://github.com/AdoptOpenJDK/openjdk-jdk11u</a></td>
</tr>
</tbody>
</table>
<p>使用这种方式需要安装<code>git</code>工具，并使用<code>git clone &lt;url&gt;</code>下载源代码。比如下载<code>jdk8u</code>使用如下命令：</p>
<pre><code class="language-bash">git clone https://github.com/AdoptOpenJDK/openjdk-jdk8u
</code></pre>
<p><code>git</code>工具使用方便，并且比从官方<code>Mercurial</code>仓库下载要快很多，<strong>推荐使用</strong>。</p>
<h3 id="3-下载mercurial仓库或者git仓库-打包文件">3. 下载<code>Mercurial</code>仓库或者<code>Git</code>仓库 打包文件</h3>
<p>除此之外，<code>OpenJDK</code>官方的<code>Mercurial</code>仓库还提供了直接下载压缩包的入口，入口在各个项目页面左侧<code>bz2</code>,<code>zip</code>,<code>gz</code>三个链接，点击即可下载。如下图所示：<br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200627100725.png" alt="" loading="lazy"></p>
<p>同样在<code>GitHub</code>上的每个项目都可以下载<code>ZIP</code>格式的打包文件。如下图所示：<br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200701092215.png" alt="" loading="lazy"></p>
<p>显然这种方式的缺点是缺少版本控制的能力，如果对项目代码进行了改动想要恢复是做不到的，也不能够方便地获取最新代码改动，但是相比前两种方式更下载更快，也不要任何额外工具。</p>
<h2 id="如何下载jdk">如何下载JDK？</h2>
<p>让人觉得矛盾的是，编译JDK之前我们需要一个已经编译好的<code>JDK</code>作为<code>Boot JDK</code>。一般需要的<code>JDK</code>版本是编译版本前一版本的<code>JDK</code>，比如编译<code>JDK8</code>需要<code>JDK7</code>,编译<code>JDK11</code>需要<code>JDK10</code>。<br>
有几种途径可以下载<code>JDK</code>：</p>
<ol>
<li>在<a href="https://www.oracle.com/java/technologies/oracle-java-archive-downloads.html">Oracle官网</a>下载 <code>Oracle JDK</code>。下载需要登录账号</li>
<li>下载<code>OpenJDK</code>
<ul>
<li>在<a href="https://jdk.java.net/">https://jdk.java.net/</a>可以找到<code>Oracle</code>提供的基于<code>OpenJDK</code>的参考实现。但大部分只有<code>Linux</code>版本<br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200701092647.png" alt="" loading="lazy"><br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200701092748.png" alt="" loading="lazy"></li>
<li>也可以使用其他组织预编译好的<code>OpenJDK</code>。比如<a href="https://adoptopenjdk.net/">AdoptOpenJDK</a>，但是没有<code>jdk8</code>以下版本</li>
</ul>
</li>
<li>在<code>Linux</code>系统下，还可以通过软件包管理器(比如<code>Ubuntu</code>下的<code>apt</code>，<code>Centos</code>下的<code>yum</code>)下载安装<code>JDK</code></li>
</ol>
<h2 id="json-compilation-database">JSON Compilation Database</h2>
<p><code>CLion</code>对<code>CMake</code>构建的项目支持很友好，但<code>OpenJDK</code>项目是基于<code>Make</code>构建的，对于使用<code>Make</code>构建的项目，<code>CLion</code>仍然可以通过<code>Compilation Database</code>来导入项目，而不用将其修改为<code>CMake</code>项目。同时也能通过<code>Compilation Database</code>实现代码的分析、跳转等功能，这对于我们进行代码调试很有帮助。</p>
<p>有关于<code>Compilation Database</code>的介绍可以参考这几篇文章：</p>
<ul>
<li><code>Clang</code>官方的<code>Compilation Database</code>介绍页面：<a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html">JSON Compilation Database Format Specification — Clang 11 documentation</a></li>
<li>这篇文章介绍了在不同场景下生成<code>Compilation database</code>的各种工具：<a href="https://sarcasm.github.io/notes/dev/compilation-database.html">Compilation database — Sarcasm notebook</a></li>
<li><code>CLion</code>的帮助页面简要介绍了<code>Compilation Database</code>，以及在<code>CLion</code>的使用：<a href="https://www.jetbrains.com/help/clion/compilation-database.html">Compilation Database - Help | CLion</a></li>
</ul>
<p>对于基于<code>Make</code>构建的<code>OpenJDK</code>项目来说，有一些工具可以生成<code>Compilation Database</code>，比如下面几个：</p>
<ul>
<li><a href="https://github.com/rizsotto/Bear">https://github.com/rizsotto/Bear</a></li>
<li><a href="https://github.com/rizsotto/scan-build">https://github.com/rizsotto/scan-build</a></li>
<li><a href="https://github.com/nickdiego/compiledb">https://github.com/nickdiego/compiledb</a></li>
</ul>
<p>通常默认生成的<code>Compilation Database</code>是一个<code>compile_commands.json</code>文件。</p>
<p>除此之外，在<code>OpenJDK 11u</code>及之后版本中，<code>OpenJDK</code>官方提供了对于<code>IDE</code>的支持，可以使用<code>make compile-commands</code>命令生成<code>Compilation Database</code>，不需要使用额外的工具，具体命令可以查看看源代码目录下的<a href="https://github.com/openjdk/jdk11u/blob/master/doc/ide.md"><code>\doc\ide.md</code></a></p>
<h2 id="如何将openjdk项目导入clion中并运行调试">如何将OpenJDK项目导入CLion中并运行/调试</h2>
<blockquote>
<p>读者可以选择先跳过本小节，然后在完成前面几个步骤之后再来根据本小节进行导入调试。</p>
</blockquote>
<p>对于如何在<code>CLion</code>中管理基于<code>Make</code>构建的项目，<code>CLion</code>的官方帮助文档中有详细的介绍：<br>
<a href="https://www.jetbrains.com/help/clion/managing-makefile-projects.html">Managing Makefile Projects</a>。</p>
<p>参考上述文档，本小节简要介绍了如何在<code>CLion</code>中导入<code>OpenJDK</code>项目并运行/调试的方法。请注意小节中所展示的图示是基于<code>Ubuntu 16.04</code>系统 + <code>CLion 2020.1.1</code> 环境下的，操作步骤基本也适用于<code>MacOS 系统</code>下同版本的<code>CLion</code>。</p>
<ol>
<li>
<p>下载安装<code>CLion</code>，并安装<code>Makefile Support</code>插件。建议使用最新版本，比较老的版本是不支持<code>Make</code>构建的项目的。</p>
</li>
<li>
<p>导入项目。打开<code>CLion</code>，选择<code>Open Or Import</code>，选择项目目录中的<code>compile_commands.json</code>文件，弹出框选择<code>Open as Project</code>，等待文件索引完成。</p>
<blockquote>
<p><code>compile_commands.json</code>的生成方法及生成位置根据不同的<code>OpenJDK</code>版本略有不同，具体位置请看下文具体场景的介绍。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200614173939.gif" alt="" loading="lazy"></figure>
</li>
<li>
<p>创建自定义<code>Build Target</code>。点击<code>File</code>菜单栏，<code>Settings | Build, Execution, Deployment | Custom Build Targets</code>，点击<code>+</code>新建一个	<code>Target</code>。</p>
<ul>
<li><code>Name</code>：<code>Target</code>的名字，之后在创建<code>Run/Debug</code>配置的时候会看到这个名字</li>
<li>点击<code>Build</code>或者<code>Clean</code>右边的三点，弹出框中点击<code>+</code>新建两个<code>External Tool</code>配置如下：<pre><code class="language-bash"># 第一个配置如下，用来指定构建指令
# Program 和 Arguments 共同构成了所要执行的命令 &quot;make all&quot;
Name: make
Program: make
Arguments: all
Working directory: {项目的根目录}

# 第二个配置如下，用来清理构建输出
# Program 和 Arguments 共同构成了所要执行的命令 &quot;make clean&quot;
Name: make clean
Program: make
Arguments: clean
Working directory: {项目的根目录}
</code></pre>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200614174833.gif" alt="" loading="lazy"></li>
<li><code>ToolChain</code>选择<code>Default</code>；<code>Build</code>选择<code>make</code>（上面创建的第一个<code>External Tool</code>）；<code>Clean</code>选择<code>make clean</code>（上面创建的第二个<code>External Tool</code>）</li>
</ul>
<blockquote>
<p>其中两个<code>External Tool</code>配置中<code>make</code>的参数可以根据需要改变。一般情况用于<code>Build</code>的配置与执行构建时<code>make</code>的<code>target</code>保持一致即可。</p>
</blockquote>
</li>
<li>
<p>创建自定义的<code>Run/Debug configuration</code>。点击<code>Run</code>菜单栏,<code>Edit Configurations</code>， 点击<code>+</code>，选择<code>Custom Build Application</code>，配置如下：</p>
<pre><code class="language-bash"># Executable 和 Program arguments 可以根据需要调试的信息自行选择
# NameL：Configure 的名称
Name: linux-x86_64-normal-server-slowdebug
# Target：选择上一步创建的 “Custom Build Target”
Target: linux-x86_64-normal-server-slowdebug
# Executable：程序执行入口，也就是需要调试的程序
Executable: 这里我们调试`java`，选择`{source_root}/build/{build_name}/jdk/bin/java`。
# Program arguments: 与 “Executable” 配合使用，指定其参数
Program arguments: 这里我们选择`-version`，简单打印一下`java`版本。
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200614175414.gif" alt="" loading="lazy"></figure>
<p>如果不想每次运行/调试前都执行<code>Build</code>操作（在这里就是<code>Make</code>构建过程，比较耗时），可以在编辑页下方<code>Before launch</code>框中删除<code>Build</code>条目。</p>
</li>
<li>
<p>点击<code>Run</code>/<code>Debug</code>开始运行/调试。</p>
<ul>
<li>如果使用的调试器是<code>gdb</code>（<code>Ubuntu</code>下默认），调试的时候可能会发现<code>gdb</code>报错：<code>Signal: SIGSEGV (Segmentation fault)</code>。解决办法是，创建用户家目录创建<code>.gdbinit</code>，内容如下：<pre><code class="language-bash">handle SIGSEGV pass noprint nostop
handle SIGBUS pass noprint nostop
</code></pre>
</li>
<li>如果使用的调试器是<code>lldb</code>（<code>MacOS</code>下默认），调试的时候可能会发现<code>lldb</code>报错：<code>SIGSEGV (signal SIGSEGV)</code>。解决办法是，在用户家目录创建<code>.lldbinit</code>，内容如下：<pre><code class="language-bash">break set -n main -C &quot;process handle --pass true --stop false SIGSEGV&quot; -C &quot;process handle --pass true --stop false SIGBUS&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<p>配合<code>File Watchers</code>插件自动更新<code>Compilation Database</code>（可选）</p>
<p>如果修改了项目代码，需要重新生成<code>Compilation Database</code>，一般情况需要重新构建才可以。</p>
<p>如果不想每次都重新手动构建，可以使用<code>Files Watcher</code>插件来实现监听变更自动重新生成。详见：<a href="https://www.jetbrains.com/help/clion/managing-makefile-projects.html#filewatcher-plugin">https://www.jetbrains.com/help/clion/managing-makefile-projects.html#filewatcher-plugin</a></p>
</li>
</ol>
<h1 id="ubuntu-1604-环境">Ubuntu 16.04 环境</h1>
<h2 id="openjdk-8">OpenJDK 8</h2>
<h3 id="1-下载openjdk8源代码">1. 下载OpenJDK8源代码</h3>
<p>我们这里选择从<code>AdoptOpenJDK</code>的<code>GitHub</code>仓库下载源代码。</p>
<pre><code class="language-bash"># 首先需要安装git工具（如果没有的话）
sudo apt-get install git
# 克隆项目代码，可能耗时较长
git clone git@github.com:AdoptOpenJDK/openjdk-jdk8u.git
</code></pre>
<h3 id="2-安装工具链及依赖">2. 安装工具链及依赖</h3>
<pre><code class="language-bash"># 首先需要下载安装 JDK7 作为 BootJDK
方法见上文
# 安装编译器及构建工具
sudo apt-get install gcc g++ gdb make
# 下载安装依赖包
sudo apt-get install libasound2-dev libfreetype6-dev libcups2-dev libfontconfig1-dev libxext-dev libxrender-dev libxtst-dev libxt-dev
</code></pre>
<h3 id="3-配置及构建">3. 配置及构建</h3>
<pre><code class="language-bash"># 首先进入 OpenJDK8 源码目录
# 配置
sh ./configure --with-debug-level=slowdebug --disable-zip-debug-info --with-target-bits=64 --with-boot-jdk=/home/jiajiawang/software/jdk/jdk1.7.0_80 --with-freetype-include=/usr/include/freetype2 --with-freetype-lib=/usr/lib/x86_64-linux-gnu/
</code></pre>
<p><code>configure</code>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>--with-debug-level</td>
<td>调试信息的级别，可选值有<code>release</code>,<code>fastdebug</code>,<code>slowdebug</code></td>
</tr>
<tr>
<td>--disable-zip-debug-info</td>
<td>禁止压缩调试信息，设置为true有助于调试</td>
</tr>
<tr>
<td>--with-target-bits</td>
<td>选择32位或者64位，根据操作系统选择</td>
</tr>
<tr>
<td>--with-boot-jdk</td>
<td><code>BootJDK</code>的位置</td>
</tr>
<tr>
<td>--with-freetype-include <br>--with-freetype-lib</td>
<td>指定<code>freetype</code>依赖位置，如果提示找不到<code>freetype</code>，需要配置这两个参数</td>
</tr>
</tbody>
</table>
<p>参数的更多说明及更多参数请参考：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/raw-file/tip/README-builds.html#configure">OpenJDK 8 Build README - Configure</a></p>
<p>我们可以使用两种工具来生成<code>Compilation Database</code></p>
<h4 id="使用bear工具">使用Bear工具</h4>
<pre><code class="language-bash"># 下载Bear工具
sudo apt-get install bear
# 构建，并使用bear工具生成Compilation Database
bear make all
</code></pre>
<h4 id="使用compiledb工具">使用compiledb工具</h4>
<pre><code class="language-bash"># 需要保证有python环境
# 安装pip
sudo apt-get install python-pip
# pip安装 compiledb
pip install compiledb
# 构建，并使用compiledb工具生成Compilation Database
compiledb make all
</code></pre>
<p>更多<code>make</code>的<code>target</code>请参考<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/raw-file/tip/README-builds.html#make">OpenJDK 8 Build README - Make</a></p>
<p>如果没有报错，完成之后应该可以在<code>./build/linux-x86_64-normal-server-slowdebug/jdk</code>目录下找到编译之后的<code>JDK</code>，验证一下是否成功</p>
<pre><code class="language-bash">~: cd build/linux-x86_64-normal-server-slowdebug/jdk/bin/
~: ./java -version
openjdk version &quot;1.8.0-internal-debug&quot;
......
</code></pre>
<p>同时项目根目录下应该同时有一个<code>compile_commands.json</code>文件，并且不为空。</p>
<h3 id="4-导入clion并调试">4. 导入CLion并调试</h3>
<p>步骤参见上文</p>
<h2 id="openjdk-11">OpenJDK 11</h2>
<h3 id="1-下载openjdk11源代码">1. 下载OpenJDK11源代码</h3>
<pre><code class="language-bash"># 首先需要安装git工具（如果没有的话）
sudo apt-get install git
# 克隆项目代码，可能耗时较长
git clone git@github.com:AdoptOpenJDK/openjdk-jdk11u.git
</code></pre>
<h3 id="2-安装工具链及依赖-2">2. 安装工具链及依赖</h3>
<pre><code class="language-bash"># 需要下载安装 JDK10 作为 BootJDK
方法见上文
# 安装编译器及构建工具
sudo apt-get install gcc g++ gdb make autoconf
# 下载安装依赖包
sudo apt-get install libfreetype6-dev libcups2-dev
sudo apt-get install libx11-dev libxext-dev libxrender-dev libxrandr-dev libxtst-dev libxt-dev
sudo apt-get install libasound2-dev libffi-dev
sudo apt-get install libfontconfig1-dev
</code></pre>
<h3 id="3-配置及构建-2">3. 配置及构建</h3>
<pre><code class="language-bash"># 配置
sh ./configure --with-debug-level=slowdebug --with-native-debug-symbols=internal --with-target-bits=64 --with-boot-jdk=/home/jiajiawang/software/jdk/jdk-10.0.2
</code></pre>
<blockquote>
<p>如果不成功，一般可能是缺少部分依赖，根据脚本给出的提示安装相应依赖即可。</p>
</blockquote>
<p><code>configure</code>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>--with-debug-level</td>
<td>调试信息的级别，可选值有<code>release</code>,<code>fastdebug</code>,<code>slowdebug</code></td>
</tr>
<tr>
<td>--with-native-debug-symbols</td>
<td>指定如何构建<code>debug symbol</code>，可选值有<code>none</code>,<code>internal</code>, <code>external</code>, <code>zipped</code>，设置为<code>internal</code>可以更好地调试</td>
</tr>
<tr>
<td>--with-target-bits</td>
<td>选择32位或者64位，根据操作系统选择</td>
</tr>
<tr>
<td>--with-boot-jdk</td>
<td><code>bootjdk</code>位置</td>
</tr>
<tr>
<td>--with-freetype-include <br>--with-freetype-lib</td>
<td>指定<code>freetype</code>依赖位置。如果提示找不到<code>freetype</code>，需要配置这两个参数</td>
</tr>
</tbody>
</table>
<p>参数的更多说明及更多参数请参考：<a href="http://hg.openjdk.java.net/jdk/jdk11/raw-file/tip/doc/building.html#running-configure">OpenJDK 11 Build README - Configure</a></p>
<pre><code class="language-bash"># 生成Compilation Database
make compile-commands
# 构建
make all
</code></pre>
<p>更多<code>make</code>的<code>target</code>请参考<a href="http://hg.openjdk.java.net/jdk/jdk11/raw-file/tip/doc/building.html#running-make">OpenJDK 11 Build README - Make</a></p>
<p>完成之后应该可以在<code>./build/linux-x86_64-normal-server-slowdebug/jdk</code>目录下找到编译之后的jdk，验证一下是否成功</p>
<pre><code class="language-bash">~: cd build/linux-x86_64-normal-server-slowdebug/jdk/bin/
~: ./java -version
openjdk version &quot;11.0.8-internal&quot; 2020-07-14
......
</code></pre>
<p>同时在<code>/build/linux-x86_64-normal-server-slowdebug/</code>目录下会有<code>compile_commands.json</code>文件，并且不为空。</p>
<h3 id="4-导入clion并调试-2">4. 导入CLion并调试</h3>
<p>大致步骤与前文介绍相同。<br>
需要注意的是在选择<code>/build/linux-x86_64-normal-server-slowdebug/</code>目录下的<code>compile_commands.json</code>文件导入项目之后需要更改项目的根目录为<code>源码的根目录</code>（这里也就是<code>openjdk-11u</code>目录）。点击菜单<code>Tools | Compilation Database | Change Project Root</code>，选择<code>源码根目录</code>（<code>openjdk-11u</code>），等待重新索引完成。<br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200615091032.gif" alt="" loading="lazy"></p>
<h1 id="macos-1015-环境">MacOS 10.15 环境</h1>
<h2 id="openjdk-8-2">OpenJDK 8</h2>
<blockquote>
<p><code>MacOS 10.15.5</code>环境下构建<code>OpenJDK</code>与<code>Linux</code>下步骤相似，但是由于<code>OpenJDK 8</code>版本较老，其中一些依赖在<code>MacOS 10.15.5</code>版本中已经无法找到，导致在配置构建过程中会出现各种问题，本文给出了一种比较简单方便的办法。</p>
</blockquote>
<h3 id="1-下载openjdk8源代码-2">1. 下载OpenJDK8源代码</h3>
<p>我们选择从<code>AdoptOpenJDK</code>的<code>github</code>仓库下载源代码</p>
<pre><code class="language-bash">git clone git@github.com:AdoptOpenJDK/openjdk-jdk8u.git
</code></pre>
<h3 id="2-安装工具链及依赖-3">2. 安装工具链及依赖</h3>
<ol>
<li>首先需要下载安装<code>jdk7</code>作为<code>bootjdk</code>，方法见文章开头。</li>
<li>安装<code>HomeBrew</code>。<code>Homebrew</code>是一款<code>MacOS</code>系统上的软件包管理系统。<pre><code class="language-bash">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;
</code></pre>
</li>
<li>安装<code>Xcode</code>。可以直接在<code>App Store</code>搜索安装，也可以在<a href="https://developer.apple.com/download/more/">https://developer.apple.com/download/more/</a>下载离线安装包安装。可以使用<code>xcodebuild</code>命令验证是否安装成功，正确输出版本号则表明正确安装。<pre><code class="language-bash">xcodebuild -version
</code></pre>
如果是离线安装的话，可能会报<code>xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance</code>错误，这是因为<code>xcodebuild</code>找不到新安装的<code>Xcode</code>，只需要执行下面这个命令即可。<pre><code>sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/
</code></pre>
</li>
<li>安装编译工具<pre><code class="language-bash"># 安装构建工具
brew install make
</code></pre>
</li>
<li>安装所需依赖<pre><code class="language-bash"># 安装freetype
brew install freetype
</code></pre>
</li>
</ol>
<h3 id="3-配置及构建-3">3. 配置及构建</h3>
<h4 id="31-修改代码">3.1 修改代码</h4>
<p>如果不对代码进行修改，在执行<code>configure</code>的时候，会报各种错误。网上也有很多针对每种错误来修改源文件来解决报错的方法， 这里给出一种更为方便的方法。<br>
<code>GitHub</code>上的<a href="https://github.com/stooke/jdk8u-xcode10">stooke/jdk8u-xcode10</a>这个项目，提供了对<code>openjdk8</code>的代码进行修改的<code>patch</code>文件，对代码修改之后，就可以正常地<code>configure</code>。</p>
<pre><code class="language-bash">git clone git@github.com:stooke/jdk8u-xcode10.git
</code></pre>
<p>这个项目本身提供了脚本来完成下载源码、下载依赖、代码修改、配置、编译、测试等工作，但我们这里只使用其中的修改代码这部分。原项目中的<code>README</code>可能已经过时了，通过查看其源代码中的<code>build8.sh</code>文件，能够大概了解其中的执行逻辑，据此我将其中的修改<code>OpenJDK8</code>代码的部分抽取出来，简化如下：</p>
<p>新建一个<code>shell</code>脚本<code>patch.sh</code>，内容如下：</p>
<pre><code class="language-bash">#!/bin/bash
# JDK8 源码所在目录
JDK_DIR=`pwd`
# 下载的jdk8u-xcode10项目所在目录
PATCH_DIR=&quot;$(dirname $JDK_DIR)/jdk8u-xcode10&quot;
PATCH_DIR=&quot;$PATCH_DIR/jdk8u-patch&quot;

applypatch() {
	cd &quot;$JDK_DIR/$1&quot;
	echo &quot;applying $1 $2&quot;
	patch -p1 &lt;$2
}

patchjdkbuild() {
	echo &quot;patch jdk&quot;
	# JDK-8019470: Changes needed to compile JDK 8 on MacOS with clang compiler
	applypatch . &quot;$PATCH_DIR/jdk8u-8019470.patch&quot;

	# JDK-8152545: Use preprocessor instead of compiling a program to generate native nio constants
	# (fixes genSocketOptionRegistry build error on 10.8)
	applypatch jdk &quot;$PATCH_DIR/jdk8u-jdk-8152545.patch&quot;

	# fix WARNINGS_ARE_ERRORS handling
	applypatch hotspot &quot;$PATCH_DIR/jdk8u-hotspot-8241285.patch&quot;

	# fix some help messages and Xcode version checks
	applypatch . &quot;$PATCH_DIR/jdk8u-buildfix1.patch&quot;
	# use correct C++ standard library
	#applypatch . &quot;$PATCH_DIR/jdk8u-libcxxfix.patch&quot;
	# misc clang-specific cleanup
	applypatch . &quot;$PATCH_DIR/jdk8u-buildfix2.patch&quot;

	# misc clang-specific cleanup; doesn't apply cleanly on top of 8019470 
	# (use -g1 for fastdebug builds)
	#applypatch . &quot;$PATCH_DIR/jdk8u-buildfix2a.patch&quot;

	# fix for clang crash if base has non-virtual destructor
	applypatch hotspot &quot;$PATCH_DIR/jdk8u-hotspot-8244878.patch&quot;
	
	applypatch hotspot &quot;$PATCH_DIR/jdk8u-hotspot-mac.patch&quot;

	# libosxapp.dylib fails to build on Mac OS 10.9 with clang
	applypatch jdk     &quot;$PATCH_DIR/jdk8u-jdk-8043646.patch&quot;

	applypatch jdk     &quot;$PATCH_DIR/jdk8u-jdk-minversion.patch&quot;
}
patchjdkbuild
</code></pre>
<p>然后执行这个脚本：</p>
<pre><code class="language-bash">bash patsh.sh
</code></pre>
<h4 id="32-配置">3.2 配置</h4>
<pre><code class="language-bash">sh ./configure MAKE=/usr/bin/make --with-toolchain-type=clang --with-debug-level=slowdebug --disable-zip-debug-info --with-target-bits=64 --with-boot-jdk=/Users/jiajiawang/Software/jdk/jdk1.7.0_80.jdk/Contents/Home/ --with-freetype-include=/usr/local/Cellar/freetype/2.10.2/include/freetype2 --with-freetype-lib=/usr/local/Cellar/freetype/2.10.2/lib/
</code></pre>
<p><code>MAKE=/usr/bin/make</code>是可选的，如果下文使用<code>Bear</code>来生成<code>Compilation Database</code>，可以不加这个参数。</p>
<p><code>configure</code>部分参数说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>--with-toolchain-type</td>
<td>使用的工具链类型，取值有<code>gcc</code>，<code>clang</code>等，可以使用<code>--help</code>来查看所有可选值</td>
</tr>
<tr>
<td>--with-debug-level</td>
<td>调试信息的级别，可选值有<code>release</code>,<code>fastdebug</code>,<code>slowdebug</code></td>
</tr>
<tr>
<td>--disable-zip-debug-info</td>
<td>禁止压缩调试信息，设置为true可以更好地调试</td>
</tr>
<tr>
<td>--with-target-bits</td>
<td>选择32位或者64位，根据操作系统选择</td>
</tr>
<tr>
<td>--with-boot-jdk</td>
<td><code>bootjdk</code>位置</td>
</tr>
<tr>
<td>--with-freetype-include <br>--with-freetype-lib</td>
<td>指定<code>freetype</code>依赖位置，在执行<code>configure</code>时如果找不到<code>freetype</code>，需要指定这两个参数</td>
</tr>
</tbody>
</table>
<p>参数的更多说明及更多参数请参考：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/raw-file/tip/README-builds.html#configure">OpenJDK 8 Build README - Configure</a></p>
<h4 id="33-构建">3.3 构建</h4>
<p>同样我们仍然可以使用<code>bear</code>或者<code>compiledb</code>来生成<code>Compilation Database</code>，但是使用<code>bear</code>过程中遇到一些问题比较繁琐，推荐使用<code>compiledb</code>。</p>
<h5 id="使用compiledb">使用compiledb</h5>
<pre><code class="language-bash"># 1. 请先确保安装了Python及pip
方法请自行搜索
# 2. 安装compiledb工具
pip install compiledb
# 3. 构建，并使用compiledb工具生成Compilation Database
compiledb make all COMPILER_WARNINGS_FATAL=false
# 可以使用 LOG=debug 选项来输出更为详细的信息
# compiledb make all LOG=debug COMPILER_WARNINGS_FATAL=false
</code></pre>
<p>使用<code>compiledb</code>可能会存在的问题是生成的<code>compile_commands.json</code>文件中所有项的<code>directory</code>项都是项目的根目录，导致一个头文件无法找到，导入<code>CLion</code>时报错，代码定义及跳转无效。原因是在<code>MacOS</code>平台，编译构建使用的可能是<code>gmake</code>，而<code>compiledb</code>对<code>gmake</code>切换路径的操作无法捕捉到，导致路径全部都是根目录。解决办法就是显示指定使用<code>make</code>而不是<code>gmake</code>，指定方法就是上一小节中在<code>Configure</code>时指定的<code>MAKE=/usr/bin/make</code>参数。</p>
<h5 id="使用bear">使用bear</h5>
<p>上面我们使用<code>compiledb</code>工具来生成<code>Compilation Database</code>，同样也可以使用<code>bear</code>工具来生成：</p>
<pre><code class="language-bash"># 1. 首先需要关闭SIP，否则生成的 Compilation Database 可能会是空的
关闭SIP的方法请自行搜索
# 2. 安装bear
brew install bear
# 3. 构建，并使用bear工具生成Compilation Database
bear make all COMPILER_WARNINGS_FATAL=false
# 可以使用 LOG=debug 选项来输出更为详细的信息
# compiledb make all LOG=debug COMPILER_WARNINGS_FATAL=false
</code></pre>
<p>如果遇到执行命令遇到报如下错误：</p>
<pre><code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdio.h:107:15: fatal error: 'stdio.h' file not found&quot;
</code></pre>
<p>可以尝试执行如下命令：</p>
<pre><code class="language-bash">sudo mount -uw /
sudo cp -R /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include /usr
</code></pre>
<p>更多<code>make</code>的<code>target</code>请参考<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/raw-file/tip/README-builds.html#make">OpenJDK 8 Build README - Make</a></p>
<p>如果没有报错，完成之后应该可以在<code>./build/macosx-x86_64-normal-server-slowdebug/jdk</code>目录下找到编译之后的<code>JDK</code>，验证一下是否成功</p>
<pre><code class="language-bash">~: cd build/macosx-x86_64-normal-server-slowdebug/jdk/bin/
~: ./java -version
openjdk version &quot;1.8.0-internal-debug&quot;
......
</code></pre>
<p>同时项目根目录下应该同时有一个<code>compile_commands.json</code>文件，并且不为空。</p>
<h3 id="4-导入clion并调试-3">4. 导入CLion并调试</h3>
<p>需要注意在创建<code>Custom Build Targets</code>时，新建的用于<code>Build</code>的<code>External Tool</code>中<code>make</code>的参数中也要加上<code>COMPILER_WARNINGS_FATAL=false</code></p>
<h2 id="openjdk-11-2">OpenJDK 11</h2>
<h3 id="1-下载openjdk11源代码-2">1. 下载OpenJDK11源代码</h3>
<pre><code class="language-bash">git clone git@github.com:AdoptOpenJDK/openjdk-jdk11u.git
</code></pre>
<h3 id="2-安装工具链及依赖-4">2. 安装工具链及依赖</h3>
<ol>
<li>
<p>首先需要下载安装<code>jdk10</code>作为<code>bootjdk</code>，方法见文章开头。</p>
</li>
<li>
<p>安装<code>HomeBrew</code>。<code>Homebrew</code>是一款<code>MacOS</code>系统上的软件包管理系统。</p>
<pre><code class="language-bash">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;
</code></pre>
</li>
<li>
<p>安装<code>Xcode</code>。可以直接在<code>App Store</code>搜索<code>Xcode</code>安装，也可以在<a href="https://developer.apple.com/download/more/">https://developer.apple.com/download/more/</a>下载离线安装包安装。可以使用<code>xcodebuild</code>命令验证是否安装成功，正确输出版本号则表明正确安装。</p>
<pre><code class="language-bash">xcodebuild -version
</code></pre>
<p>如果是离线安装的话，可能会报<code>xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance</code>错误，这是因为<code>xcodebuild</code>找不到新安装的<code>Xcode</code>，只需要执行下面这个命令即可。</p>
<pre><code>sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/
</code></pre>
</li>
<li>
<p>安装编译工具</p>
<pre><code class="language-bash">brew install autoconf
brew install make
</code></pre>
</li>
<li>
<p>安装所需依赖</p>
<pre><code class="language-bash"># 安装freetype
brew install freetype
</code></pre>
</li>
</ol>
<h3 id="3-配置及编译">3. 配置及编译</h3>
<pre><code class="language-bash"># 配置
sh ./configure --with-debug-level=slowdebug --with-native-debug-symbols=internal --with-target-bits=64 --with-boot-jdk=/Users/jiajiawang/Software/jdk/jdk-10.0.2+13/Contents/Home
</code></pre>
<p><code>configure</code>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>--with-debug-level</td>
<td>调试信息的级别，可选值有<code>release</code>,<code>fastdebug</code>,<code>slowdebug</code></td>
</tr>
<tr>
<td>--with-native-debug-symbols</td>
<td>指定如何构建<code>debug symbol</code>，可选值有<code>none</code>,<code>internal</code>, <code>external</code>, <code>zipped</code>，设置为<code>internal</code>可以更好地调试</td>
</tr>
<tr>
<td>--with-target-bits</td>
<td>选择32位或者64位，根据操作系统选择</td>
</tr>
<tr>
<td>--with-boot-jdk</td>
<td><code>bootjdk</code>位置</td>
</tr>
<tr>
<td>--with-freetype-include <br>--with-freetype-lib</td>
<td>指定<code>freetype</code>依赖位置，在执行<code>configure</code>时如果找不到<code>freetype</code>，需要指定这两个参数</td>
</tr>
</tbody>
</table>
<p>参数的更多说明及更多参数请参考：<a href="http://hg.openjdk.java.net/jdk/jdk11/raw-file/tip/doc/building.html#running-configure">OpenJDK 11 Build README - Configure</a></p>
<pre><code class="language-bash"># 生成Compilation Database
make compile-commands
# 构建
make all
</code></pre>
<p>完成之后，应该在<code>/build/linux-x86_64-normal-server-slowdebug/</code>目录下会有<code>compile_commands.json</code>文件。</p>
<p>更多<code>make</code>的<code>target</code>请参考<a href="http://hg.openjdk.java.net/jdk/jdk11/raw-file/tip/doc/building.html#running-make">OpenJDK 11 Build README - Make</a></p>
<p>完成之后应该可以在<code>./build/macosx-x86_64-normal-server-slowdebug/jdk</code>目录下找到编译之后的jdk，验证一下是否成功</p>
<pre><code class="language-bash">~: cd build/macosx-x86_64-normal-server-slowdebug/jdk/bin/
~: ./java -version
openjdk version &quot;11.0.8-internal&quot; 2020-07-14
......
</code></pre>
<p>同时在<code>./build/macosx-x86_64-normal-server-slowdebug/</code>目录下会有<code>compile_commands.json</code>文件，并且不为空。</p>
<h3 id="4-导入clion并调试-4">4. 导入CLion并调试</h3>
<p>大致步骤与前文介绍相同。<br>
需要注意的是在选择<code>/build/macosx-x86_64-normal-server-slowdebug/</code>目录下的<code>compile_commands.json</code>文件导入项目之后需要更改项目的根目录为<code>源码的根目录</code>(这里也就是<code>openjdk-11u</code>目录)。点击菜单<code>Tools | Compilation Database | Change Project Root</code>，将项目的根目录设置为<code>源码根目录</code>(<code>openjdk-11u</code>)，等待重新索引完成。<br>
<img src="https://keaper-cn-image.oss-cn-beijing.aliyuncs.com/20200615091032.gif" alt="" loading="lazy"></p>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://openjdk.java.net/">OpenJDK</a></li>
<li><a href="https://hg.openjdk.java.net/jdk8u/jdk8u/raw-file/tip/README-builds.html">OpenJDK 8 Build README</a></li>
<li><a href="https://hg.openjdk.java.net/jdk/jdk11/raw-file/tip/doc/building.html">OpenJDK 11 Build README</a></li>
<li><a href="https://github.com/rizsotto/Bear">rizsotto/Bear: Bear is a tool that generates a compilation database for clang tooling</a></li>
<li><a href="https://github.com/nickdiego/compiledb">nickdiego/compiledb: Tool for generating Clang's JSON Compilation Database files for make-based build systems.</a></li>
<li><a href="https://www.jetbrains.com/help/clion/managing-makefile-projects.html">Managing Makefile Projects</a></li>
<li><a href="https://blog.jetbrains.com/clion/2020/02/dealing-with-makefiles/">Dealing with Makefile Projects in CLion: Status Update</a></li>
<li><a href="https://blog.jetbrains.com/clion/2020/03/openjdk-with-clion/">Tips &amp; Tricks: Develop OpenJDK in CLion with Pleasure</a></li>
<li><a href="https://dzone.com/articles/debugging-openjdk">Debugging OpenJDK - DZone DevOps</a></li>
<li><a href="https://sarcasm.github.io/notes/dev/compilation-database.html">Compilation database — Sarcasm notebook</a></li>
<li><a href="https://developer.apple.com/download/more/">More Software Downloads - Apple Developer</a></li>
<li><a href="https://github.com/stooke/jdk8u-xcode10">stooke/jdk8u-xcode10: How to compile JDK 8u with Xcode 9, 10 or 11 on macOS.</a></li>
</ol>
]]></content>
    </entry>
</feed>